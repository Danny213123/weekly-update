<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&family=Sora:wght@400;500;600;700&display=swap');

        :root {
            --canvas-bg: #000000;
            --grid-opacity: 0.05;
            --ui-font: "Space Grotesk", "IBM Plex Sans", "Sora", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
        }

        /* Force a standard font for consistency in screenshots (overridden by theme vars) */
        .export-font {
            font-family: var(--preview-font, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1f2937;
        }

        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 0;
        }

        body {
            font-family: var(--ui-font);
        }

        body.sharp-ui * {
            border-radius: 0 !important;
        }

        body.export-mode main {
            padding: 0 !important;
            overflow: hidden;
        }

        body.export-mode .preview-stage {
            justify-content: flex-start;
            align-items: flex-start;
        }

        body.export-mode .studio-inspector {
            display: none !important;
        }

        .bg-grid-pattern {
            background-image: linear-gradient(rgba(255, 255, 255, var(--grid-opacity, 0.05)) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, var(--grid-opacity, 0.05)) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .canvas-bg {
            background-color: var(--canvas-bg, #000000);
        }

        .dashboard-root {
            background-color: var(--canvas-bg, #000000);
            background-image:
                linear-gradient(rgba(255, 255, 255, var(--grid-opacity, 0.05)) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, var(--grid-opacity, 0.05)) 1px, transparent 1px),
                linear-gradient(var(--preview-bg, #0f172a), var(--preview-bg, #0f172a)),
                linear-gradient(var(--canvas-bg, #000000), var(--canvas-bg, #000000));
            background-size: 20px 20px, 20px 20px, 100% 100%, 100% 100%;
            background-repeat: repeat, repeat, no-repeat, no-repeat;
            background-position: top left, top left, top left, top left;
            color: var(--preview-text, #ffffff);
            border: 1px solid var(--preview-border, #334155);
            border-radius: var(--preview-radius, 2px);
            box-shadow: var(--preview-shadow, 0 20px 45px rgba(0, 0, 0, 0.45));
            padding: var(--preview-padding, 4px);
            font-family: var(--preview-font, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif);
            position: relative;
            overflow: hidden;
        }

        .preview-stage {
            flex: 1;
            min-width: 520px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .tile-canvas {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 360px;
        }

        .tile-canvas .layout-card {
            position: absolute;
            touch-action: none;
        }

        .studio-inspector {
            width: 320px;
            min-width: 280px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .inspector-panel {
            background: #0b1220;
            border: 1px solid #1f2937;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .inspector-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.26em;
            color: #94a3b8;
        }

        .inspector-subtitle {
            font-size: 11px;
            color: #cbd5f5;
            text-transform: uppercase;
            letter-spacing: 0.12em;
        }

        .inspector-divider {
            height: 1px;
            background: #1f2937;
        }

        .inspector-button {
            background: #0f172a;
            border: 1px solid #243244;
            color: #e2e8f0;
            padding: 8px 12px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            transition: border-color 0.2s ease, color 0.2s ease;
        }

        .inspector-button:hover {
            border-color: #38bdf8;
            color: #f8fafc;
        }

        .tile-library {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tile-library-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: #64748b;
            margin-top: 6px;
        }

        .tile-library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #1f2937;
            padding: 8px 10px;
            cursor: pointer;
        }

        .tile-library-item.active {
            border-color: #38bdf8;
            color: #e2e8f0;
        }

        .tile-library-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .tile-library-action {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            border: 1px solid #243244;
            padding: 4px 8px;
            background: transparent;
            color: #94a3b8;
        }

        .tile-library-action.active {
            border-color: #ef4444;
            color: #fecaca;
        }

        .tile-editor-section {
            display: none;
        }

        .tile-toolbar {
            position: absolute;
            top: 8px;
            left: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid #334155;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 9px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 6;
        }

        .tile-toolbar button {
            border: 1px solid #334155;
            padding: 2px 6px;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            background: transparent;
            color: #e2e8f0;
        }

        .preview-editing .layout-card:hover .tile-toolbar {
            opacity: 1;
            pointer-events: auto;
        }

        .big-stat-card {
            background: linear-gradient(to bottom right, var(--bigstat-bg-from, #334155), var(--bigstat-bg-to, #1e293b));
            border: var(--panel-border-width, 1px) solid var(--bigstat-border, #4b5563);
            border-radius: var(--panel-radius, 2px);
            height: var(--bigstat-height, 140px);
            padding: var(--bigstat-padding, 24px);
        }

        .big-stat-value {
            color: var(--bigstat-value, #ffffff);
        }

        .big-stat-label {
            color: var(--bigstat-label, #bfdbfe);
        }

        .highlight-card {
            background: var(--highlights-bg, #1e293b);
            border: var(--panel-border-width, 1px) solid var(--highlights-border, #4b5563);
            border-radius: var(--panel-radius, 2px);
        }

        .highlight-accent {
            background: var(--highlights-accent, #3b82f6);
        }

        .highlight-title {
            color: var(--highlights-title, #93c5fd);
        }

        .highlight-bullet {
            color: var(--highlights-bullet, #60a5fa);
        }

        .highlight-text {
            color: var(--highlights-text, #d1d5db);
        }

        .blogs-card {
            background: var(--blogs-bg, #f8fafc);
            border: var(--panel-border-width, 1px) solid var(--blogs-border, #d1d5db);
            border-radius: var(--panel-radius, 2px);
        }

        .blogs-header {
            background: var(--blogs-header-bg, #475569);
            color: var(--blogs-header-text, #ffffff);
        }

        .blogs-subtitle {
            color: var(--blogs-subtitle-text, #ffffff);
            opacity: var(--blogs-subtitle-opacity, 0.6);
        }

        .blog-row {
            border-bottom: 1px solid var(--blogs-border, #d1d5db);
        }

        .blog-row.even {
            background: var(--blogs-row-even, #ffffff);
        }

        .blog-row.odd {
            background: var(--blogs-row-odd, #f9fafb);
        }

        .blog-title {
            color: var(--blogs-title, #1d4ed8);
        }

        .blog-views {
            background: var(--blogs-views-bg, #e5e7eb);
            color: var(--blogs-views-text, #1f2937);
        }

        .demo-card {
            background: var(--demographics-bg, #ffffff);
            border: var(--panel-border-width, 1px) solid var(--demographics-divider, #d1d5db);
            border-radius: var(--panel-radius, 2px);
        }

        .demo-header {
            background: var(--demographics-header-bg, #64748b);
            color: var(--demographics-header-text, #ffffff);
        }

        .demo-grid {
            border-top: 1px solid var(--demographics-divider, #d1d5db);
            --tw-divide-opacity: 1;
            border-color: var(--demographics-divider, #d1d5db);
        }

        .demo-grid > :not([hidden]) ~ :not([hidden]) {
            border-color: var(--demographics-divider, #d1d5db);
        }

        .demo-label {
            color: var(--demographics-label, #4b5563);
        }

        .demo-value {
            color: var(--demographics-value, #111827);
        }

        .graph-card {
            background: var(--graph-bg, #0f172a);
            border: var(--panel-border-width, 1px) solid var(--graph-border, #334155);
        }

        .graph-header {
            background: var(--graph-header-bg, #111827);
            color: var(--graph-header-text, #e2e8f0);
        }

        .graph-subtitle {
            color: var(--graph-subtitle-text, #94a3b8);
            opacity: 0.8;
        }

        .graph-body {
            padding: 12px;
        }

        .graph-svg {
            width: 100%;
            height: var(--graph-height, 140px);
            display: block;
        }

        .graph-labels {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin-top: 6px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--graph-label, #94a3b8);
        }

        .kpi-card {
            border-radius: var(--panel-radius, 2px);
            opacity: var(--kpi-opacity, 1);
        }

        .kpi-title {
            color: var(--kpi-title-color, #111827);
        }

        .kpi-value {
            color: var(--kpi-value-color, #111827);
        }

        .kpi-delta {
            background: var(--kpi-delta-bg, #e5e7eb);
            color: var(--kpi-delta-text, #4b5563);
        }

        body.sidebar-content-hidden .sidebar-content-section {
            display: none;
        }

        body.hide-left-panel .app-sidebar {
            display: none !important;
        }

        body.hide-controls .studio-inspector {
            display: none !important;
        }

        .canvas-surface {
            cursor: grab;
        }

        .canvas-surface.is-panning {
            cursor: grabbing;
        }

        .resize-handle {
            display: none;
            position: absolute;
            bottom: 6px;
            right: 6px;
            width: 10px;
            height: 10px;
            border-right: 2px solid rgba(148, 163, 184, 0.8);
            border-bottom: 2px solid rgba(148, 163, 184, 0.8);
            cursor: nwse-resize;
            z-index: 6;
        }

        .preview-editing .layout-card:hover .resize-handle {
            display: block;
        }

        .resize-target {
            max-width: 100%;
            min-width: 0;
            box-sizing: border-box;
        }

        .preview-resize-handle {
            display: none;
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 16px;
            height: 16px;
            border-right: 2px solid rgba(148, 163, 184, 0.9);
            border-bottom: 2px solid rgba(148, 163, 184, 0.9);
            cursor: nwse-resize;
            z-index: 7;
            background: rgba(15, 23, 42, 0.6);
        }

        .preview-editing #dashboard-preview:hover .preview-resize-handle {
            display: block;
        }

        input,
        textarea,
        select {
            background-color: #0f172a;
            border: 1px solid #1f2937;
            color: #e2e8f0;
            padding: 0.5rem;
            border-radius: 0.25rem;
            width: 100%;
            font-size: 0.8rem;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #38bdf8;
        }

        input[type="checkbox"] {
            width: auto;
            padding: 0;
            background: transparent;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 11px;
            color: #cbd5f5;
        }

        .control-row input[type="color"] {
            width: 30px;
            height: 22px;
            padding: 0;
            border: none;
            background: transparent;
        }

        .control-row input[type="range"] {
            width: 100%;
        }

        label {
            display: block;
            font-size: 0.75rem;
            color: #9ca3af;
            margin-bottom: 0.25rem;
            margin-top: 0.75rem;
        }

        h3 {
            color: #38bdf8;
            font-weight: bold;
            margin-top: 1.5rem;
            border-bottom: 1px solid #374151;
            padding-bottom: 0.5rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .section-group {
            background: rgba(15, 23, 42, 0.7);
            padding: 10px;
            border: 1px solid #1f2937;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .remove-btn {
            color: #f87171;
            font-size: 0.7rem;
            cursor: pointer;
            text-decoration: underline;
        }

        .add-btn {
            width: 100%;
            background-color: #0f172a;
            color: #e2e8f0;
            font-size: 0.75rem;
            padding: 0.6rem;
            border-radius: 0.25rem;
            border: 1px solid #243244;
            margin-top: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            transition: border-color 0.2s ease, color 0.2s ease;
        }

        .add-btn:hover {
            border-color: #38bdf8;
            color: #f8fafc;
        }

        /* Pre-define KPI card color styles for proper export */
        .kpi-blue {
            background: linear-gradient(to bottom, #dbeafe, #bfdbfe);
        }

        .kpi-blue .kpi-title {
            color: #1e3a8a;
        }

        .kpi-teal {
            background: linear-gradient(to bottom, #ccfbf1, #99f6e4);
        }

        .kpi-teal .kpi-title {
            color: #134e4a;
        }

        .kpi-orange {
            background: linear-gradient(to bottom, #ffedd5, #fed7aa);
        }

        .kpi-orange .kpi-title {
            color: #7c2d12;
        }

        .kpi-indigo {
            background: linear-gradient(to bottom, #e0e7ff, #c7d2fe);
        }

        .kpi-indigo .kpi-title {
            color: #312e81;
        }

        .kpi-purple {
            background: linear-gradient(to bottom, #f3e8ff, #e9d5ff);
        }

        .kpi-purple .kpi-title {
            color: #581c87;
        }

        .kpi-pink {
            background: linear-gradient(to bottom, #fce7f3, #fbcfe8);
        }

        .kpi-pink .kpi-title {
            color: #831843;
        }

        .kpi-green {
            background: linear-gradient(to bottom, #dcfce7, #bbf7d0);
        }

        .kpi-green .kpi-title {
            color: #14532d;
        }

        .kpi-red {
            background: linear-gradient(to bottom, #fee2e2, #fecaca);
        }

        .kpi-red .kpi-title {
            color: #7f1d1d;
        }

        .layout-card {
            position: relative;
            overflow: hidden;
            min-width: 0;
            box-sizing: border-box;
        }

        .drag-handle {
            display: none;
            position: absolute;
            top: 6px;
            right: 6px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            background: rgba(15, 23, 42, 0.9);
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 4px;
            padding: 2px 6px;
            cursor: grab;
            z-index: 5;
        }

        .preview-editing .layout-card:hover {
            outline: 1px dashed rgba(56, 189, 248, 0.6);
            outline-offset: 2px;
            cursor: grab;
        }

        .preview-editing .layout-card:hover .drag-handle {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .layout-card.dragging {
            opacity: 0.6;
        }

        .layout-card.tile-selected {
            outline: 1px solid #38bdf8;
            outline-offset: 2px;
        }

        .layout-zone {
            min-height: 20px;
        }

        .editable {
            cursor: text;
        }

        .editable:focus {
            outline: 1px solid rgba(56, 189, 248, 0.7);
            outline-offset: 2px;
            border-radius: 2px;
        }

        /* Loading Spinner */
        .loader {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 5px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>

<body class="bg-gray-900 h-screen flex flex-col text-white sidebar-content-hidden sharp-ui">
    <header class="bg-gray-900 border-b border-gray-700 px-6 py-3 flex items-center justify-between">
        <div>
            <div class="text-lg font-bold text-cyan-400">Dashboard Studio</div>
            <div class="text-xs text-gray-500">Monthly + Yearly Builder</div>
        </div>
        <div class="flex items-center gap-3 text-xs text-gray-300">
            <button id="toggle-left-panel"
                class="bg-gray-800 border border-gray-600 px-3 py-1 text-[11px] uppercase tracking-widest text-gray-200">Hide
                Left Panel</button>
            <button id="toggle-controls-panel"
                class="bg-gray-800 border border-gray-600 px-3 py-1 text-[11px] uppercase tracking-widest text-gray-200">Hide
                Controls</button>
            <label for="mode-select" class="uppercase tracking-widest text-gray-400">Mode</label>
            <select id="mode-select" class="bg-gray-800 border border-gray-600 rounded px-2 py-1 text-sm text-white">
                <option value="monthly">Monthly</option>
                <option value="yearly">Yearly</option>
            </select>
        </div>
    </header>

    <div id="app-container" class="flex-1 overflow-hidden"></div>

    <template id="monthly-template">
        <div class="bg-gray-900 h-full flex overflow-hidden font-sans text-white">
            <aside class="app-sidebar w-1/3 min-w-[400px] bg-gray-800 border-r border-gray-700 flex flex-col h-full z-10 shadow-xl">
                <div class="p-4 border-b border-gray-700 bg-gray-900">
                    <h1 class="text-xl font-bold text-cyan-400">Dashboard Builder</h1>
                    <p class="text-xs text-gray-400">Monthly</p>
                </div>

                <div class="flex-1 overflow-y-auto p-4 space-y-4">

                    <h3>JSON Import/Export</h3>
                    <div class="section-group text-xs space-y-2">
                        <label>Paste JSON</label>
                        <textarea id="json-input" rows="6" class="text-xs" placeholder='Paste JSON here. You can also wrap it as {"mode":"monthly","data":{...}}'></textarea>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="applyJson()" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded text-xs font-bold">Apply JSON</button>
                            <button onclick="copyJson()" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded text-xs font-bold">Copy JSON</button>
                        </div>
                        <button onclick="copyJsonTemplate()" class="bg-slate-800 hover:bg-slate-700 text-white py-2 rounded text-xs font-bold">Copy JSON Template</button>
                        <label>Load JSON file</label>
                        <input type="file" id="json-file-input" accept=".json" onchange="loadJsonFile(this.files[0])">
                        <div class="text-[10px] text-gray-400">Tip: Generate JSON in any tool and paste it here.</div>
                    </div>

                    <!-- Layout + Theme controls moved to preview panel -->

                </div>

                <div class="p-4 border-t border-gray-700 bg-gray-900 grid grid-cols-2 gap-4">
                    <button onclick="downloadPNG()"
                        class="bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded font-bold shadow-lg">Download PNG</button>
                    <button onclick="downloadPDF()"
                        class="bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded font-bold shadow-lg">Download
                        PDF</button>
                </div>
            </aside>

            <main class="canvas-surface flex-1 canvas-bg p-6 flex items-start gap-6 overflow-auto bg-grid-pattern h-full">

                <div class="preview-stage">
                    <div id="dashboard-preview"
                        class="export-font dashboard-root" style="width: var(--preview-width, 1100px);">
                        <div id="tile-canvas" class="tile-canvas"></div>
                        <div class="preview-resize-handle" title="Resize Canvas"></div>
                    </div>
                </div>

                <aside class="studio-inspector">
                    <div class="inspector-panel" id="tile-controls-panel">
                        <div class="inspector-title">Tile Controls</div>
                        <button id="preview-edit-toggle" class="inspector-button" type="button">Update Preview</button>
                        <div class="inspector-divider"></div>
                        <div class="inspector-subtitle">Tile Types</div>
                        <div id="tile-type-list" class="tile-library"></div>
                        <div class="inspector-divider"></div>
                        <div class="inspector-subtitle">Selected Tile</div>
                        <div id="selected-tile-label" class="text-xs text-slate-300 uppercase tracking-wider">KPI Row</div>
                        <div id="tile-controls-body" class="space-y-3">
                            <div class="tile-editor-section space-y-3" data-tile-editor="kpis">
                                <div class="inspector-subtitle">KPI Cards</div>
                                <div id="kpi-inputs"></div>
                                <button onclick="addItem('kpi')" class="add-btn">+ Add KPI Card</button>
                                <div class="tile-style-controls" data-style-group="KPI Delta"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="bigStat">
                                <div class="inspector-subtitle">Big Stat</div>
                                <div class="section-group">
                                    <label>Big Stat Label</label>
                                    <input type="text" id="big-stat-label-input" oninput="updateBigStatLabel()" value="Total Blogs Released">
                                    <label>Big Stat Value</label>
                                    <input type="text" id="big-stat-input" oninput="updateBigStat()" value="13">
                                </div>
                                <div class="tile-style-controls" data-style-group="Big Stat"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="highlights">
                                <div class="inspector-subtitle">Highlights</div>
                                <div class="section-group">
                                    <label>Highlights Title</label>
                                    <input type="text" id="highlight-title-input" oninput="updateHighlightTitle()" value="Monthly Highlights">
                                </div>
                                <div id="highlight-inputs"></div>
                                <button onclick="addItem('highlight')" class="add-btn">+ Add Highlight Point</button>
                                <div class="tile-style-controls" data-style-group="Highlights"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="blogs">
                                <div class="inspector-subtitle">Blogs</div>
                                <div class="section-group">
                                    <label>Section Title</label>
                                    <input type="text" id="blogs-title-input" oninput="updateBlogsTitle()" value="New Monthly Blogs Traffic">
                                    <label>Subtitle</label>
                                    <input type="text" id="blogs-subtitle-input" oninput="updateBlogsSubtitle()" value="Sorted by Views">
                                </div>
                                <div id="blog-inputs"></div>
                                <button onclick="addItem('blog')" class="add-btn">+ Add Blog Post</button>
                                <div class="tile-style-controls" data-style-group="Blogs"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="graph">
                                <div class="inspector-subtitle">Graph</div>
                                <div class="section-group">
                                    <label>Title</label>
                                    <input type="text" id="graph-title-input" oninput="updateGraphTitle()" value="Traffic Trend">
                                    <label>Subtitle</label>
                                    <input type="text" id="graph-subtitle-input" oninput="updateGraphSubtitle()" value="Last 8 Weeks">
                                    <label>Chart Type</label>
                                    <select id="graph-type-input" onchange="updateGraphType(this.value)">
                                        <option value="line">Line</option>
                                        <option value="bar">Bar</option>
                                    </select>
                                </div>
                                <div id="graph-inputs"></div>
                                <button onclick="addItem('graphPoint')" class="add-btn">+ Add Point</button>
                                <div class="tile-style-controls" data-style-group="Graph"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="demographics">
                                <div class="inspector-subtitle">Demographics</div>
                                <div class="section-group">
                                    <label>Section Title</label>
                                    <input type="text" id="demographics-title-input" oninput="updateDemographicsTitle()" value="Top Demographics">
                                </div>
                                <div id="demo-inputs"></div>
                                <button onclick="addItem('demo')" class="add-btn">+ Add Demographic</button>
                                <div class="tile-style-controls" data-style-group="Demographics"></div>
                            </div>
                        </div>
                    </div>

                    <div class="inspector-panel" id="box-controls-panel">
                        <div class="inspector-title">Canvas Controls</div>
                        <div id="box-quick-controls" class="space-y-3"></div>
                        <div class="inspector-divider"></div>
                        <div id="box-theme-controls" class="space-y-3"></div>
                    </div>
                </aside>

                <template id="tile-template-kpis">
                    <div class="layout-card tile-kpis" data-tile-type="kpis">
                        <div class="tile-toolbar">
                            <span>KPI Row</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="resize-target kpi-preview-container grid text-center"
                            style="gap: var(--kpi-gap, var(--layout-gap, 4px));"></div>
                    </div>
                </template>

                <template id="tile-template-bigStat">
                    <div class="layout-card" data-tile-type="bigStat">
                        <div class="tile-toolbar">
                            <span>Big Stat</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="big-stat-card resize-target"
                            style="padding: var(--bigstat-padding, 24px); text-align: center; height: var(--bigstat-height, 140px); display: flex; flex-direction: column; justify-content: center; align-items: center;">
                            <div class="editable big-stat-value" contenteditable="true" data-edit="bigStat.value"
                                style="font-size: 72px; font-weight: 700; line-height: 1;">13</div>
                            <div class="editable big-stat-label" contenteditable="true" data-edit="bigStat.label"
                                style="font-size: 14px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 4px;">
                                Total Blogs Released</div>
                        </div>
                    </div>
                </template>

                <template id="tile-template-highlights">
                    <div class="layout-card" data-tile-type="highlights">
                        <div class="tile-toolbar">
                            <span>Highlights</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="highlight-card resize-target p-5 rounded-sm flex-1 text-sm leading-relaxed flex flex-col">
                            <div class="flex items-center gap-2 mb-3 pb-2"
                                style="border-bottom: 1px solid var(--highlights-border, #4b5563);">
                                <div class="w-2 h-6 highlight-accent rounded-sm"></div>
                                <span class="editable highlight-title font-bold uppercase tracking-widest" contenteditable="true"
                                    data-edit="highlights.title">Monthly Highlights</span>
                            </div>
                            <div class="highlight-preview-list space-y-3 pl-2"></div>
                        </div>
                    </div>
                </template>

                <template id="tile-template-blogs">
                    <div class="layout-card" data-tile-type="blogs">
                        <div class="tile-toolbar">
                            <span>Blogs</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="blogs-card resize-target flex-1 flex flex-col">
                            <div class="blogs-header text-xs font-bold p-3 flex justify-between items-center uppercase">
                                <span class="editable" contenteditable="true" data-edit="blogs.title">New Monthly Blogs Traffic</span>
                                <span class="editable blogs-subtitle text-[10px]" contenteditable="true" data-edit="blogs.subtitle">Sorted by Views</span>
                            </div>
                            <div class="blog-preview-list text-sm"></div>
                        </div>
                    </div>
                </template>

                <template id="tile-template-graph">
                    <div class="layout-card" data-tile-type="graph">
                        <div class="tile-toolbar">
                            <span>Graph</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="graph-card resize-target flex flex-col">
                            <div class="graph-header text-[11px] font-bold p-3 flex justify-between items-center uppercase">
                                <span class="editable" contenteditable="true" data-edit="graph.title">Traffic Trend</span>
                                <span class="editable graph-subtitle text-[10px]" contenteditable="true" data-edit="graph.subtitle">Last 8 Weeks</span>
                            </div>
                            <div class="graph-body">
                                <svg class="graph-svg" viewBox="0 0 300 140" preserveAspectRatio="none"></svg>
                                <div class="graph-labels"></div>
                            </div>
                        </div>
                    </div>
                </template>

                <template id="tile-template-demographics">
                    <div class="layout-card" data-tile-type="demographics">
                        <div class="tile-toolbar">
                            <span>Demographics</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="demo-card resize-target h-fit">
                            <div class="editable demo-header text-xs font-bold p-2 px-3 uppercase" contenteditable="true"
                                data-edit="demographics.title">Top Demographics</div>
                            <div class="demo-grid grid grid-cols-3 divide-x divide-y text-xs text-center"></div>
                        </div>
                    </div>
                </template>
            </main>
        </div>
    </template>

    <template id="yearly-template">
        <div class="bg-gray-900 h-full flex overflow-hidden font-sans text-white">
            <aside class="app-sidebar w-1/3 min-w-[420px] bg-gray-800 border-r border-gray-700 flex flex-col h-full z-10 shadow-xl">
                <div class="p-4 border-b border-gray-700 bg-gray-900">
                    <h1 class="text-xl font-bold text-cyan-400">Dashboard Builder</h1>
                    <p class="text-xs text-gray-400">Yearly</p>
                </div>

                <div class="flex-1 overflow-y-auto p-4 space-y-4">

                    <h3>JSON Import/Export</h3>
                    <div class="section-group text-xs space-y-2">
                        <label>Paste JSON</label>
                        <textarea id="json-input" rows="6" class="text-xs" placeholder='Paste JSON here. You can also wrap it as {"mode":"yearly","data":{...}}'></textarea>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="applyJson()" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded text-xs font-bold">Apply JSON</button>
                            <button onclick="copyJson()" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded text-xs font-bold">Copy JSON</button>
                        </div>
                        <button onclick="copyJsonTemplate()" class="bg-slate-800 hover:bg-slate-700 text-white py-2 rounded text-xs font-bold">Copy JSON Template</button>
                        <label>Load JSON file</label>
                        <input type="file" id="json-file-input" accept=".json" onchange="loadJsonFile(this.files[0])">
                        <div class="text-[10px] text-gray-400">Tip: Generate JSON in any tool and paste it here.</div>
                    </div>

                    <!-- Layout + Theme controls moved to preview panel -->

                </div>

                <div class="p-4 border-t border-gray-700 bg-gray-900 grid grid-cols-2 gap-4">
                    <button onclick="downloadPNG()"
                        class="bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded font-bold shadow-lg">Download PNG</button>
                    <button onclick="downloadPDF()"
                        class="bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded font-bold shadow-lg">Download
                        PDF</button>
                </div>
            </aside>

            <main class="canvas-surface flex-1 canvas-bg p-6 flex items-start gap-6 overflow-auto bg-grid-pattern h-full">

                <div class="preview-stage">
                    <div id="dashboard-preview"
                        class="export-font dashboard-root" style="width: var(--preview-width, 1100px);">
                        <div id="tile-canvas" class="tile-canvas"></div>
                        <div class="preview-resize-handle" title="Resize Canvas"></div>
                    </div>
                </div>

                <aside class="studio-inspector">
                    <div class="inspector-panel" id="tile-controls-panel">
                        <div class="inspector-title">Tile Controls</div>
                        <button id="preview-edit-toggle" class="inspector-button" type="button">Update Preview</button>
                        <div class="inspector-divider"></div>
                        <div class="inspector-subtitle">Tile Types</div>
                        <div id="tile-type-list" class="tile-library"></div>
                        <div class="inspector-divider"></div>
                        <div class="inspector-subtitle">Selected Tile</div>
                        <div id="selected-tile-label" class="text-xs text-slate-300 uppercase tracking-wider">KPI Row</div>
                        <div id="tile-controls-body" class="space-y-3">
                            <div class="tile-editor-section space-y-3" data-tile-editor="kpis">
                                <div class="inspector-subtitle">KPI Cards</div>
                                <div id="kpi-inputs"></div>
                                <button onclick="addItem('kpi')" class="add-btn">+ Add KPI Card</button>
                                <div class="tile-style-controls" data-style-group="KPI Delta"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="bigStat">
                                <div class="inspector-subtitle">Hero Stat</div>
                                <div class="section-group">
                                    <label>Hero Stat Value</label>
                                    <input type="text" id="big-stat-input" oninput="updateBigStat()" value="181">
                                    <label>Hero Stat Label</label>
                                    <input type="text" id="big-stat-label-input" oninput="updateBigStat()" value="Blogs Released in 2025">
                                </div>
                                <div class="tile-style-controls" data-style-group="Big Stat"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="highlights">
                                <div class="inspector-subtitle">Highlights</div>
                                <div class="section-group">
                                    <label>Section Title</label>
                                    <input type="text" id="highlight-title-input" oninput="updateHighlightTitle()" value="Yearly Highlights">
                                </div>
                                <div id="highlight-inputs"></div>
                                <button onclick="addItem('highlight')" class="add-btn">+ Add Highlight Point</button>
                                <div class="tile-style-controls" data-style-group="Highlights"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="blogs">
                                <div class="inspector-subtitle">Top Blogs</div>
                                <div class="section-group">
                                    <label>Section Title</label>
                                    <input type="text" id="blogs-title-input" oninput="updateBlogsTitle()" value="Top Performing Content (2025)">
                                    <label>Subtitle</label>
                                    <input type="text" id="blogs-subtitle-input" oninput="updateBlogsSubtitle()" value="Sorted by Views">
                                </div>
                                <div id="blog-inputs"></div>
                                <button onclick="addItem('blog')" class="add-btn">+ Add Blog Post</button>
                                <div class="tile-style-controls" data-style-group="Blogs"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="graph">
                                <div class="inspector-subtitle">Graph</div>
                                <div class="section-group">
                                    <label>Title</label>
                                    <input type="text" id="graph-title-input" oninput="updateGraphTitle()" value="Monthly Growth">
                                    <label>Subtitle</label>
                                    <input type="text" id="graph-subtitle-input" oninput="updateGraphSubtitle()" value="2025">
                                    <label>Chart Type</label>
                                    <select id="graph-type-input" onchange="updateGraphType(this.value)">
                                        <option value="line">Line</option>
                                        <option value="bar">Bar</option>
                                    </select>
                                </div>
                                <div id="graph-inputs"></div>
                                <button onclick="addItem('graphPoint')" class="add-btn">+ Add Point</button>
                                <div class="tile-style-controls" data-style-group="Graph"></div>
                            </div>
                            <div class="tile-editor-section space-y-3" data-tile-editor="demographics">
                                <div class="inspector-subtitle">Traffic Sources</div>
                                <div class="section-group">
                                    <label>Section Title</label>
                                    <input type="text" id="demographics-title-input" oninput="updateDemographicsTitle()" value="Traffic Acquisition">
                                </div>
                                <div id="demo-inputs"></div>
                                <button onclick="addItem('demo')" class="add-btn">+ Add Source</button>
                                <div class="tile-style-controls" data-style-group="Demographics"></div>
                            </div>
                        </div>
                    </div>

                    <div class="inspector-panel" id="box-controls-panel">
                        <div class="inspector-title">Canvas Controls</div>
                        <div id="box-quick-controls" class="space-y-3"></div>
                        <div class="inspector-divider"></div>
                        <div id="box-theme-controls" class="space-y-3"></div>
                    </div>
                </aside>
                <template id="tile-template-kpis">
                    <div class="layout-card tile-kpis" data-tile-type="kpis">
                        <div class="tile-toolbar">
                            <span>KPI Row</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="resize-target kpi-preview-container grid text-center"
                            style="gap: var(--kpi-gap, var(--layout-gap, 4px));"></div>
                    </div>
                </template>

                <template id="tile-template-bigStat">
                    <div class="layout-card" data-tile-type="bigStat">
                        <div class="tile-toolbar">
                            <span>Big Stat</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="big-stat-card resize-target"
                            style="padding: var(--bigstat-padding, 24px); text-align: center; height: var(--bigstat-height, 140px); display: flex; flex-direction: column; justify-content: center; align-items: center;">
                            <div class="editable big-stat-value" contenteditable="true" data-edit="bigStat.value"
                                style="font-size: 72px; font-weight: 700; line-height: 1;">13</div>
                            <div class="editable big-stat-label" contenteditable="true" data-edit="bigStat.label"
                                style="font-size: 14px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 4px;">
                                Total Blogs Released</div>
                        </div>
                    </div>
                </template>

                <template id="tile-template-highlights">
                    <div class="layout-card" data-tile-type="highlights">
                        <div class="tile-toolbar">
                            <span>Highlights</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="highlight-card resize-target p-5 rounded-sm flex-1 text-sm leading-relaxed flex flex-col">
                            <div class="flex items-center gap-2 mb-3 pb-2"
                                style="border-bottom: 1px solid var(--highlights-border, #4b5563);">
                                <div class="w-2 h-6 highlight-accent rounded-sm"></div>
                                <span class="editable highlight-title font-bold uppercase tracking-widest" contenteditable="true"
                                    data-edit="highlights.title">Monthly Highlights</span>
                            </div>
                            <div class="highlight-preview-list space-y-3 pl-2"></div>
                        </div>
                    </div>
                </template>

                <template id="tile-template-blogs">
                    <div class="layout-card" data-tile-type="blogs">
                        <div class="tile-toolbar">
                            <span>Blogs</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="blogs-card resize-target flex-1 flex flex-col">
                            <div class="blogs-header text-xs font-bold p-3 flex justify-between items-center uppercase">
                                <span class="editable" contenteditable="true" data-edit="blogs.title">New Monthly Blogs Traffic</span>
                                <span class="editable blogs-subtitle text-[10px]" contenteditable="true" data-edit="blogs.subtitle">Sorted by Views</span>
                            </div>
                            <div class="blog-preview-list text-sm"></div>
                        </div>
                    </div>
                </template>

                <template id="tile-template-graph">
                    <div class="layout-card" data-tile-type="graph">
                        <div class="tile-toolbar">
                            <span>Graph</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="graph-card resize-target flex flex-col">
                            <div class="graph-header text-[11px] font-bold p-3 flex justify-between items-center uppercase">
                                <span class="editable" contenteditable="true" data-edit="graph.title">Traffic Trend</span>
                                <span class="editable graph-subtitle text-[10px]" contenteditable="true" data-edit="graph.subtitle">Last 8 Weeks</span>
                            </div>
                            <div class="graph-body">
                                <svg class="graph-svg" viewBox="0 0 300 140" preserveAspectRatio="none"></svg>
                                <div class="graph-labels"></div>
                            </div>
                        </div>
                    </div>
                </template>

                <template id="tile-template-demographics">
                    <div class="layout-card" data-tile-type="demographics">
                        <div class="tile-toolbar">
                            <span>Demographics</span>
                            <button type="button" data-tile-action="edit">Edit</button>
                            <button type="button" data-tile-action="duplicate">Duplicate</button>
                            <button type="button" data-tile-action="remove">Remove</button>
                        </div>
                        <div class="drag-handle">Move</div>
                        <div class="resize-handle" title="Resize"></div>
                        <div class="demo-card resize-target h-fit">
                            <div class="editable demo-header text-xs font-bold p-2 px-3 uppercase" contenteditable="true"
                                data-edit="demographics.title">Top Demographics</div>
                            <div class="demo-grid grid grid-cols-3 divide-x divide-y text-xs text-center"></div>
                        </div>
                    </div>
                </template>

            </main>
        </div>
    </template>

    <script>
        const appContainer = document.getElementById('app-container');
        const modeSelect = document.getElementById('mode-select');
        const toggleLeftPanelBtn = document.getElementById('toggle-left-panel');
        const toggleControlsBtn = document.getElementById('toggle-controls-panel');
        const templates = {
            monthly: document.getElementById('monthly-template'),
            yearly: document.getElementById('yearly-template')
        };

        let activeApp = null;

        const DEFAULT_KPI_COLORS = [
            { from: "#dbeafe", to: "#bfdbfe", titleColor: "#1e3a8a", valueColor: "#111827" },
            { from: "#ccfbf1", to: "#99f6e4", titleColor: "#134e4a", valueColor: "#111827" },
            { from: "#ffedd5", to: "#fed7aa", titleColor: "#7c2d12", valueColor: "#111827" },
            { from: "#e0e7ff", to: "#c7d2fe", titleColor: "#312e81", valueColor: "#111827" },
            { from: "#f3e8ff", to: "#e9d5ff", titleColor: "#581c87", valueColor: "#111827" },
            { from: "#fce7f3", to: "#fbcfe8", titleColor: "#831843", valueColor: "#111827" },
            { from: "#dcfce7", to: "#bbf7d0", titleColor: "#14532d", valueColor: "#111827" },
            { from: "#fee2e2", to: "#fecaca", titleColor: "#7f1d1d", valueColor: "#111827" }
        ];

        const DEFAULT_THEME = {
            schemaVersion: 2,
            typography: {
                fontFamily: '"Space Grotesk", "IBM Plex Sans", "Sora", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif'
            },
            canvas: {
                background: "#000000",
                gridOpacity: 0.05
            },
            preview: {
                background: "#0f172a",
                backgroundAlpha: 1,
                text: "#ffffff",
                border: "#334155",
                radius: 0,
                padding: 0,
                width: 1100,
                height: 0,
                shadow: "0 20px 45px rgba(0,0,0,0.45)"
            },
            layout: {
                gap: 0,
                kpiGap: 0
            },
            panel: {
                radius: 0,
                border: "#4b5563",
                borderWidth: 1
            },
            effects: {
                panelOpacity: 1,
                kpiOpacity: 1
            },
            kpi: {
                titleColor: "#111827",
                valueColor: "#111827",
                deltaPositiveBg: "#22c55e",
                deltaPositiveOpacity: 0.25,
                deltaPositiveText: "#166534",
                deltaNegativeBg: "#ef4444",
                deltaNegativeOpacity: 0.25,
                deltaNegativeText: "#991b1b",
                deltaNeutralBg: "#e5e7eb",
                deltaNeutralOpacity: 1,
                deltaNeutralText: "#4b5563"
            },
            bigStat: {
                bgFrom: "#334155",
                bgTo: "#1e293b",
                valueColor: "#ffffff",
                labelColor: "#bfdbfe",
                border: "#4b5563",
                height: 140,
                padding: 24
            },
            highlights: {
                bg: "#1e293b",
                border: "#4b5563",
                title: "#93c5fd",
                accent: "#3b82f6",
                bullet: "#60a5fa",
                text: "#d1d5db"
            },
            blogs: {
                headerBg: "#475569",
                headerText: "#ffffff",
                subtitleText: "#ffffff",
                subtitleOpacity: 0.6,
                rowEven: "#ffffff",
                rowOdd: "#f9fafb",
                title: "#1d4ed8",
                viewsBg: "#e5e7eb",
                viewsText: "#1f2937",
                border: "#d1d5db",
                bg: "#f8fafc"
            },
            demographics: {
                headerBg: "#64748b",
                headerText: "#ffffff",
                bg: "#ffffff",
                divider: "#d1d5db",
                label: "#4b5563",
                value: "#111827"
            },
            graph: {
                headerBg: "#0f172a",
                headerText: "#e2e8f0",
                subtitleText: "#94a3b8",
                bg: "#0b1220",
                border: "#334155",
                grid: "#1f2937",
                line: "#38bdf8",
                fill: "#38bdf8",
                fillOpacity: 0.2,
                point: "#e2e8f0",
                label: "#94a3b8",
                height: 140
            }
        };

        const YEARLY_THEME_DEFAULTS = cloneValue(DEFAULT_THEME);
        YEARLY_THEME_DEFAULTS.bigStat.height = 110;
        YEARLY_THEME_DEFAULTS.bigStat.padding = 16;
        YEARLY_THEME_DEFAULTS.bigStat.valueColor = "#38bdf8";

        function cloneValue(value) {
            return JSON.parse(JSON.stringify(value));
        }

        function isPlainObject(value) {
            return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
        }

        function applyDefaults(target, defaults) {
            Object.keys(defaults).forEach((key) => {
                const defVal = defaults[key];
                if (target[key] === undefined || target[key] === null) {
                    target[key] = cloneValue(defVal);
                    return;
                }
                if (isPlainObject(defVal)) {
                    if (!isPlainObject(target[key])) {
                        target[key] = cloneValue(defVal);
                    } else {
                        applyDefaults(target[key], defVal);
                    }
                }
            });
            return target;
        }

        function normalizeThemeState(state, defaults = DEFAULT_THEME) {
            if (!state.theme || typeof state.theme !== 'object') {
                state.theme = cloneValue(defaults);
                return;
            }
            applyDefaults(state.theme, defaults);
        }

        function getDefaultKpiTheme(index) {
            const palette = DEFAULT_KPI_COLORS[index % DEFAULT_KPI_COLORS.length];
            return cloneValue(palette);
        }

        function normalizeKpiList(kpis) {
            if (!Array.isArray(kpis)) return;
            kpis.forEach((kpi, i) => {
                if (!kpi || typeof kpi !== 'object') {
                    kpis[i] = { title: `Metric ${i + 1}`, prev: "", curr: "", deltaOverride: "", theme: getDefaultKpiTheme(i) };
                    return;
                }
                if (kpi.prev === undefined || kpi.prev === null) kpi.prev = "";
                if (kpi.curr === undefined || kpi.curr === null) kpi.curr = "";
                if (!kpi.title) kpi.title = `Metric ${i + 1}`;
                if (kpi.deltaOverride === undefined || kpi.deltaOverride === null) kpi.deltaOverride = "";
                if (!kpi.theme || typeof kpi.theme !== 'object') {
                    kpi.theme = getDefaultKpiTheme(i);
                } else {
                    applyDefaults(kpi.theme, getDefaultKpiTheme(i));
                }
            });
        }

        function parseNumberLike(value) {
            const raw = value === undefined || value === null ? '' : String(value).trim();
            const numericCandidate = raw.replace(/,/g, '');
            const isNumeric = numericCandidate !== '' && /^-?\d+(\.\d+)?$/.test(numericCandidate);
            return { raw, numeric: isNumeric ? Number(numericCandidate) : null, isNumeric };
        }

        function formatNumberLike(value) {
            const parsed = parseNumberLike(value);
            if (parsed.isNumeric) {
                return parsed.numeric.toLocaleString();
            }
            return parsed.raw;
        }

        function applyAlpha(color, alpha) {
            if (alpha === undefined || alpha === null) return color;
            const normalizedAlpha = Math.max(0, Math.min(1, Number(alpha)));
            if (normalizedAlpha >= 1) return color;
            if (!color || typeof color !== 'string') return color;
            if (color.startsWith('rgba') || color.startsWith('hsla')) return color;
            if (color.startsWith('rgb')) {
                const match = color.match(/rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i);
                if (!match) return color;
                const [, r, g, b] = match;
                return `rgba(${r}, ${g}, ${b}, ${normalizedAlpha})`;
            }
            if (color.startsWith('#')) {
                const hex = color.replace('#', '');
                if (hex.length === 3) {
                    const r = parseInt(hex[0] + hex[0], 16);
                    const g = parseInt(hex[1] + hex[1], 16);
                    const b = parseInt(hex[2] + hex[2], 16);
                    return `rgba(${r}, ${g}, ${b}, ${normalizedAlpha})`;
                }
                if (hex.length >= 6) {
                    const r = parseInt(hex.substring(0, 2), 16);
                    const g = parseInt(hex.substring(2, 4), 16);
                    const b = parseInt(hex.substring(4, 6), 16);
                    return `rgba(${r}, ${g}, ${b}, ${normalizedAlpha})`;
                }
            }
            return color;
        }

        function detectDeltaSign(value) {
            if (!value) return 0;
            const cleaned = String(value).replace(/%/g, '').trim();
            const parsed = parseNumberLike(cleaned);
            if (parsed.isNumeric) return parsed.numeric === 0 ? 0 : parsed.numeric > 0 ? 1 : -1;
            if (cleaned.includes('-')) return -1;
            if (cleaned.includes('+')) return 1;
            return 0;
        }

        const SNAP_SIZE = 10;
        const SNAP_THRESHOLD = 6;

        function snapToGrid(value, size = SNAP_SIZE) {
            return Math.round(value / size) * size;
        }

        function snapToSibling(value, siblings, axis) {
            let snapped = value;
            if (!Array.isArray(siblings)) return snapped;
            siblings.forEach((sibling) => {
                const rect = sibling.getBoundingClientRect();
                const target = axis === 'height' ? rect.height : rect.width;
                if (Math.abs(snapped - target) <= SNAP_THRESHOLD) {
                    snapped = target;
                }
            });
            return snapped;
        }

        function applyThemeToPreview(state) {
            const preview = document.getElementById('dashboard-preview');
            if (!preview || !state) return;
            const theme = state.theme || DEFAULT_THEME;
            const panelOpacity = theme.effects?.panelOpacity ?? 1;
            const kpiOpacity = theme.effects?.kpiOpacity ?? 1;

            document.documentElement.style.setProperty('--canvas-bg', theme.canvas?.background || '#000000');
            document.documentElement.style.setProperty('--grid-opacity', theme.canvas?.gridOpacity ?? 0.05);
            preview.style.setProperty('--canvas-bg', theme.canvas?.background || '#000000');
            preview.style.setProperty('--grid-opacity', theme.canvas?.gridOpacity ?? 0.05);

            preview.style.setProperty('--preview-bg', applyAlpha(theme.preview?.background || '#0f172a', theme.preview?.backgroundAlpha ?? 1));
            preview.style.setProperty('--preview-text', theme.preview?.text || '#ffffff');
            preview.style.setProperty('--preview-border', theme.preview?.border || '#334155');
            preview.style.setProperty('--preview-radius', `${theme.preview?.radius ?? 2}px`);
            preview.style.setProperty('--preview-padding', `${theme.preview?.padding ?? 4}px`);
            preview.style.setProperty('--preview-width', `${theme.preview?.width ?? 1100}px`);
            preview.style.setProperty('--preview-shadow', theme.preview?.shadow || '0 20px 45px rgba(0,0,0,0.45)');
            preview.style.setProperty('--preview-font', theme.typography?.fontFamily || DEFAULT_THEME.typography.fontFamily);
            const previewHeight = Number(theme.preview?.height || 0);
            preview.style.height = previewHeight > 0 ? `${previewHeight}px` : '';

            preview.style.setProperty('--panel-radius', `${theme.panel?.radius ?? 2}px`);
            preview.style.setProperty('--panel-border-width', `${theme.panel?.borderWidth ?? 1}px`);
            preview.style.setProperty('--panel-border', theme.panel?.border || '#4b5563');

            preview.style.setProperty('--bigstat-bg-from', applyAlpha(theme.bigStat?.bgFrom || '#334155', panelOpacity));
            preview.style.setProperty('--bigstat-bg-to', applyAlpha(theme.bigStat?.bgTo || '#1e293b', panelOpacity));
            preview.style.setProperty('--bigstat-border', theme.bigStat?.border || '#4b5563');
            preview.style.setProperty('--bigstat-value', theme.bigStat?.valueColor || '#ffffff');
            preview.style.setProperty('--bigstat-label', theme.bigStat?.labelColor || '#bfdbfe');
            preview.style.setProperty('--bigstat-height', `${theme.bigStat?.height ?? 140}px`);
            preview.style.setProperty('--bigstat-padding', `${theme.bigStat?.padding ?? 24}px`);

            preview.style.setProperty('--highlights-bg', applyAlpha(theme.highlights?.bg || '#1e293b', panelOpacity));
            preview.style.setProperty('--highlights-border', theme.highlights?.border || '#4b5563');
            preview.style.setProperty('--highlights-title', theme.highlights?.title || '#93c5fd');
            preview.style.setProperty('--highlights-accent', theme.highlights?.accent || '#3b82f6');
            preview.style.setProperty('--highlights-bullet', theme.highlights?.bullet || '#60a5fa');
            preview.style.setProperty('--highlights-text', theme.highlights?.text || '#d1d5db');

            preview.style.setProperty('--blogs-header-bg', applyAlpha(theme.blogs?.headerBg || '#475569', panelOpacity));
            preview.style.setProperty('--blogs-header-text', theme.blogs?.headerText || '#ffffff');
            preview.style.setProperty('--blogs-subtitle-text', theme.blogs?.subtitleText || '#ffffff');
            preview.style.setProperty('--blogs-subtitle-opacity', theme.blogs?.subtitleOpacity ?? 0.6);
            preview.style.setProperty('--blogs-row-even', applyAlpha(theme.blogs?.rowEven || '#ffffff', panelOpacity));
            preview.style.setProperty('--blogs-row-odd', applyAlpha(theme.blogs?.rowOdd || '#f9fafb', panelOpacity));
            preview.style.setProperty('--blogs-title', theme.blogs?.title || '#1d4ed8');
            preview.style.setProperty('--blogs-views-bg', theme.blogs?.viewsBg || '#e5e7eb');
            preview.style.setProperty('--blogs-views-text', theme.blogs?.viewsText || '#1f2937');
            preview.style.setProperty('--blogs-border', theme.blogs?.border || '#d1d5db');
            preview.style.setProperty('--blogs-bg', applyAlpha(theme.blogs?.bg || '#f8fafc', panelOpacity));

            preview.style.setProperty('--demographics-header-bg', applyAlpha(theme.demographics?.headerBg || '#64748b', panelOpacity));
            preview.style.setProperty('--demographics-header-text', theme.demographics?.headerText || '#ffffff');
            preview.style.setProperty('--demographics-bg', applyAlpha(theme.demographics?.bg || '#ffffff', panelOpacity));
            preview.style.setProperty('--demographics-divider', theme.demographics?.divider || '#d1d5db');
            preview.style.setProperty('--demographics-label', theme.demographics?.label || '#4b5563');
            preview.style.setProperty('--demographics-value', theme.demographics?.value || '#111827');

            const graphFillOpacity = theme.graph?.fillOpacity ?? 0.2;
            preview.style.setProperty('--graph-header-bg', applyAlpha(theme.graph?.headerBg || '#111827', panelOpacity));
            preview.style.setProperty('--graph-header-text', theme.graph?.headerText || '#e2e8f0');
            preview.style.setProperty('--graph-subtitle-text', theme.graph?.subtitleText || '#94a3b8');
            preview.style.setProperty('--graph-bg', applyAlpha(theme.graph?.bg || '#0b1220', panelOpacity));
            preview.style.setProperty('--graph-border', theme.graph?.border || '#334155');
            preview.style.setProperty('--graph-grid', theme.graph?.grid || '#1f2937');
            preview.style.setProperty('--graph-line', theme.graph?.line || '#38bdf8');
            preview.style.setProperty('--graph-fill', applyAlpha(theme.graph?.fill || '#38bdf8', graphFillOpacity));
            preview.style.setProperty('--graph-point', theme.graph?.point || '#e2e8f0');
            preview.style.setProperty('--graph-label', theme.graph?.label || '#94a3b8');
            preview.style.setProperty('--graph-height', `${theme.graph?.height ?? 140}px`);

            preview.style.setProperty('--kpi-opacity', kpiOpacity);
            preview.style.setProperty('--kpi-title-color', theme.kpi?.titleColor || '#111827');
            preview.style.setProperty('--kpi-value-color', theme.kpi?.valueColor || '#111827');

            preview.style.setProperty('--layout-gap', `${theme.layout?.gap ?? 0}px`);
            preview.style.setProperty('--kpi-gap', `${theme.layout?.kpiGap ?? (theme.layout?.gap ?? 0)}px`);

            (state.kpis || []).forEach((kpi, index) => {
                const kpiTheme = kpi.theme || getDefaultKpiTheme(index);
                preview.style.setProperty(`--kpi-${index}-from`, applyAlpha(kpiTheme.from, kpiOpacity));
                preview.style.setProperty(`--kpi-${index}-to`, applyAlpha(kpiTheme.to, kpiOpacity));
                preview.style.setProperty(`--kpi-${index}-title`, kpiTheme.titleColor || theme.kpi?.titleColor || '#111827');
                preview.style.setProperty(`--kpi-${index}-value`, kpiTheme.valueColor || theme.kpi?.valueColor || '#111827');
            });
        }

        function getByPath(obj, path) {
            return path.split('.').reduce((acc, key) => (acc ? acc[key] : undefined), obj);
        }

        function setByPath(obj, path, value) {
            const parts = path.split('.');
            let cursor = obj;
            for (let i = 0; i < parts.length - 1; i += 1) {
                const key = parts[i];
                if (!cursor[key] || typeof cursor[key] !== 'object') {
                    cursor[key] = {};
                }
                cursor = cursor[key];
            }
            cursor[parts[parts.length - 1]] = value;
        }

        const THEME_CONTROL_GROUPS = [
            {
                title: "Global",
                controls: [
                    { label: "Preview Background", type: "color", path: "preview.background" },
                    { label: "Preview Background Opacity", type: "range", path: "preview.backgroundAlpha", min: 0.2, max: 1, step: 0.05 },
                    { label: "Preview Border", type: "color", path: "preview.border" },
                    { label: "Preview Padding", type: "range", path: "preview.padding", min: 0, max: 12, step: 1 },
                    { label: "Preview Width", type: "range", path: "preview.width", min: 800, max: 1400, step: 10 },
                    { label: "Preview Shadow", type: "text", path: "preview.shadow" },
                    { label: "Canvas Background", type: "color", path: "canvas.background" },
                    { label: "Grid Opacity", type: "range", path: "canvas.gridOpacity", min: 0, max: 0.2, step: 0.01 }
                ]
            },
            {
                title: "Panels",
                controls: [
                    { label: "Panel Border", type: "color", path: "panel.border" },
                    { label: "Layout Gap", type: "range", path: "layout.gap", min: 0, max: 12, step: 1 },
                    { label: "KPI Gap", type: "range", path: "layout.kpiGap", min: 0, max: 12, step: 1 },
                    { label: "Panel Opacity", type: "range", path: "effects.panelOpacity", min: 0.4, max: 1, step: 0.05 }
                ]
            },
            {
                title: "Big Stat",
                controls: [
                    { label: "Background From", type: "color", path: "bigStat.bgFrom" },
                    { label: "Background To", type: "color", path: "bigStat.bgTo" },
                    { label: "Value Color", type: "color", path: "bigStat.valueColor" },
                    { label: "Label Color", type: "color", path: "bigStat.labelColor" },
                    { label: "Border Color", type: "color", path: "bigStat.border" },
                    { label: "Height", type: "range", path: "bigStat.height", min: 90, max: 200, step: 1 },
                    { label: "Padding", type: "range", path: "bigStat.padding", min: 8, max: 32, step: 1 }
                ]
            },
            {
                title: "Highlights",
                controls: [
                    { label: "Background", type: "color", path: "highlights.bg" },
                    { label: "Border", type: "color", path: "highlights.border" },
                    { label: "Title Color", type: "color", path: "highlights.title" },
                    { label: "Accent Color", type: "color", path: "highlights.accent" },
                    { label: "Bullet Color", type: "color", path: "highlights.bullet" },
                    { label: "Text Color", type: "color", path: "highlights.text" }
                ]
            },
            {
                title: "Blogs",
                controls: [
                    { label: "Header Background", type: "color", path: "blogs.headerBg" },
                    { label: "Header Text", type: "color", path: "blogs.headerText" },
                    { label: "Subtitle Text", type: "color", path: "blogs.subtitleText" },
                    { label: "Subtitle Opacity", type: "range", path: "blogs.subtitleOpacity", min: 0.1, max: 1, step: 0.05 },
                    { label: "Row Even", type: "color", path: "blogs.rowEven" },
                    { label: "Row Odd", type: "color", path: "blogs.rowOdd" },
                    { label: "Title Color", type: "color", path: "blogs.title" },
                    { label: "Views Background", type: "color", path: "blogs.viewsBg" },
                    { label: "Views Text", type: "color", path: "blogs.viewsText" },
                    { label: "Border", type: "color", path: "blogs.border" },
                    { label: "Panel Background", type: "color", path: "blogs.bg" }
                ]
            },
            {
                title: "Demographics",
                controls: [
                    { label: "Header Background", type: "color", path: "demographics.headerBg" },
                    { label: "Header Text", type: "color", path: "demographics.headerText" },
                    { label: "Panel Background", type: "color", path: "demographics.bg" },
                    { label: "Divider", type: "color", path: "demographics.divider" },
                    { label: "Label Color", type: "color", path: "demographics.label" },
                    { label: "Value Color", type: "color", path: "demographics.value" }
                ]
            },
            {
                title: "Graph",
                controls: [
                    { label: "Header Background", type: "color", path: "graph.headerBg" },
                    { label: "Header Text", type: "color", path: "graph.headerText" },
                    { label: "Subtitle Text", type: "color", path: "graph.subtitleText" },
                    { label: "Panel Background", type: "color", path: "graph.bg" },
                    { label: "Border", type: "color", path: "graph.border" },
                    { label: "Grid", type: "color", path: "graph.grid" },
                    { label: "Line", type: "color", path: "graph.line" },
                    { label: "Fill", type: "color", path: "graph.fill" },
                    { label: "Fill Opacity", type: "range", path: "graph.fillOpacity", min: 0.05, max: 0.8, step: 0.05 },
                    { label: "Point Color", type: "color", path: "graph.point" },
                    { label: "Label Color", type: "color", path: "graph.label" },
                    { label: "Chart Height", type: "range", path: "graph.height", min: 80, max: 240, step: 5 }
                ]
            },
            {
                title: "KPI Delta",
                controls: [
                    { label: "Positive Background", type: "color", path: "kpi.deltaPositiveBg" },
                    { label: "Positive Opacity", type: "range", path: "kpi.deltaPositiveOpacity", min: 0.1, max: 1, step: 0.05 },
                    { label: "Positive Text", type: "color", path: "kpi.deltaPositiveText" },
                    { label: "Negative Background", type: "color", path: "kpi.deltaNegativeBg" },
                    { label: "Negative Opacity", type: "range", path: "kpi.deltaNegativeOpacity", min: 0.1, max: 1, step: 0.05 },
                    { label: "Negative Text", type: "color", path: "kpi.deltaNegativeText" },
                    { label: "Neutral Background", type: "color", path: "kpi.deltaNeutralBg" },
                    { label: "Neutral Opacity", type: "range", path: "kpi.deltaNeutralOpacity", min: 0.1, max: 1, step: 0.05 },
                    { label: "Neutral Text", type: "color", path: "kpi.deltaNeutralText" },
                    { label: "KPI Card Opacity", type: "range", path: "effects.kpiOpacity", min: 0.4, max: 1, step: 0.05 }
                ]
            }
        ];

        function renderThemeControls(container, state, onChange, activeGroup) {
            if (!container || !state) return;
            container.innerHTML = '';

            const groups = activeGroup
                ? THEME_CONTROL_GROUPS.filter((group) => group.title === activeGroup)
                : THEME_CONTROL_GROUPS;

            groups.forEach((group) => {
                const title = document.createElement('div');
                title.className = 'text-[10px] uppercase tracking-wider text-gray-400 font-bold mt-2';
                title.textContent = group.title;
                container.appendChild(title);

                group.controls.forEach((control) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'space-y-1';

                    const label = document.createElement('label');
                    label.textContent = control.label;
                    wrapper.appendChild(label);

                    const input = document.createElement('input');
                    if (control.type === 'range') {
                        input.type = 'range';
                        input.min = control.min;
                        input.max = control.max;
                        input.step = control.step;
                    } else if (control.type === 'color') {
                        input.type = 'color';
                    } else {
                        input.type = 'text';
                    }

                    const currentValue = getByPath(state.theme, control.path);
                    if (control.type === 'range') {
                        input.value = currentValue ?? control.min ?? 0;
                    } else {
                        input.value = currentValue ?? '';
                    }

                    input.addEventListener('input', () => {
                        const nextValue = control.type === 'range' ? Number(input.value) : input.value;
                        setByPath(state.theme, control.path, nextValue);
                        if (onChange) onChange();
                    });

                    wrapper.appendChild(input);
                    container.appendChild(wrapper);
                });
            });
        }

        const PREVIEW_COLOR_CONTROLS = [
            { label: "Canvas BG", path: "canvas.background" },
            { label: "Preview BG", path: "preview.background" },
            { label: "Preview Border", path: "preview.border" },
            { label: "Accent", path: "highlights.accent" },
            { label: "BigStat From", path: "bigStat.bgFrom" },
            { label: "BigStat To", path: "bigStat.bgTo" }
        ];

        const FONT_CHOICES = [
            { label: "Space Grotesk", value: '"Space Grotesk", "IBM Plex Sans", "Sora", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif' },
            { label: "IBM Plex Sans", value: '"IBM Plex Sans", "Space Grotesk", "Sora", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif' },
            { label: "Sora", value: '"Sora", "Space Grotesk", "IBM Plex Sans", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif' },
            { label: "System", value: 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif' }
        ];

        function renderPreviewColorControls(container, state, onChange) {
            if (!container || !state) return;
            container.innerHTML = '';
            PREVIEW_COLOR_CONTROLS.forEach((control) => {
                const row = document.createElement('div');
                row.className = 'control-row';
                const label = document.createElement('span');
                label.textContent = control.label;
                const input = document.createElement('input');
                input.type = 'color';
                const currentValue = getByPath(state.theme, control.path) || '#ffffff';
                input.value = currentValue;
                input.addEventListener('input', () => {
                    setByPath(state.theme, control.path, input.value);
                    if (onChange) onChange();
                });
                row.appendChild(label);
                row.appendChild(input);
                container.appendChild(row);
            });
        }

        function exposeHandlers(handlers) {
            const previous = {};
            Object.keys(handlers).forEach((name) => {
                previous[name] = window[name];
                window[name] = handlers[name];
            });
            return () => {
                Object.keys(handlers).forEach((name) => {
                    if (previous[name]) {
                        window[name] = previous[name];
                    } else {
                        delete window[name];
                    }
                });
            };
        }

        function updatePanelToggleLabels() {
            if (toggleLeftPanelBtn) {
                toggleLeftPanelBtn.textContent = document.body.classList.contains('hide-left-panel')
                    ? 'Show Left Panel'
                    : 'Hide Left Panel';
            }
            if (toggleControlsBtn) {
                toggleControlsBtn.textContent = document.body.classList.contains('hide-controls')
                    ? 'Show Controls'
                    : 'Hide Controls';
            }
        }

        function applyPanelPreferences() {
            const hideLeft = localStorage.getItem('dashboardStudio.hideLeftPanel') === '1';
            const hideControls = localStorage.getItem('dashboardStudio.hideControls') === '1';
            document.body.classList.toggle('hide-left-panel', hideLeft);
            document.body.classList.toggle('hide-controls', hideControls);
            updatePanelToggleLabels();
        }

        if (toggleLeftPanelBtn) {
            toggleLeftPanelBtn.addEventListener('click', () => {
                const next = !document.body.classList.contains('hide-left-panel');
                document.body.classList.toggle('hide-left-panel', next);
                localStorage.setItem('dashboardStudio.hideLeftPanel', next ? '1' : '0');
                updatePanelToggleLabels();
            });
        }

        if (toggleControlsBtn) {
            toggleControlsBtn.addEventListener('click', () => {
                const next = !document.body.classList.contains('hide-controls');
                document.body.classList.toggle('hide-controls', next);
                localStorage.setItem('dashboardStudio.hideControls', next ? '1' : '0');
                updatePanelToggleLabels();
            });
        }

        applyPanelPreferences();

        function getModeFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const mode = params.get('mode');
            return mode === 'yearly' ? 'yearly' : 'monthly';
        }

        function setModeUrl(mode) {
            const url = new URL(window.location.href);
            url.searchParams.set('mode', mode);
            window.history.replaceState({}, '', url);
        }

        function loadMode(mode) {
            const nextMode = mode === 'yearly' ? 'yearly' : 'monthly';
            if (activeApp && activeApp.destroy) {
                activeApp.destroy();
            }
            appContainer.innerHTML = '';
            appContainer.appendChild(templates[nextMode].content.cloneNode(true));
            activeApp = nextMode === 'yearly' ? initYearlyApp() : initMonthlyApp();
            modeSelect.value = nextMode;
            setModeUrl(nextMode);
        }

        modeSelect.addEventListener('change', () => {
            loadMode(modeSelect.value);
        });

        loadMode(getModeFromUrl());

        function initMonthlyApp() {
            // --- APP CONFIG ---
            const DASHBOARD_TYPE = 'monthly';
            let dashboardId = null;
            let saveTimer = null;
            let cleanupGlobals = null;

            // --- DATA STATE ---
            let state = {
                schemaVersion: 2,
                kpis: [
                    { title: "Active Users", prev: 3800, curr: 4200 },
                    { title: "New Users", prev: 3000, curr: 2400 },
                    { title: "Search Views", prev: 12000, curr: 13600 },
                    { title: "Social Views", prev: 2000, curr: 2200 }
                ],
                highlights: [
                    "Month-over-month user activity has grown significantly due to organic search optimization.",
                    "New user acquisitions saw a slight dip, but returning users increased by 8.5%.",
                    "Community outreach programs are scheduled to boost engagement in Q3."
                ],
                blogs: [
                    { title: "Power Up Qwen 3 with AMD", url: "#", views: "6.5K" },
                    { title: "Llama 4 Developer Quickstart", url: "#", views: "1.5K" },
                    { title: "Supercharge DeepSeek-R1", url: "#", views: "1.3K" }
                ],
                demographics: [
                    { country: "USA", val: "3.8K" },
                    { country: "China", val: "1.1K" },
                    { country: "Russia", val: "0.9K" }
                ],
                graph: {
                    title: "Traffic Trend",
                    subtitle: "Last 8 Weeks",
                    type: "line",
                    series: [
                        { label: "W1", value: "120" },
                        { label: "W2", value: "160" },
                        { label: "W3", value: "140" },
                        { label: "W4", value: "210" },
                        { label: "W5", value: "180" },
                        { label: "W6", value: "240" }
                    ]
                },
                bigStat: "13",
                bigStatLabel: "Total Blogs Released",
                highlightTitle: "Monthly Highlights",
                blogTitle: "New Monthly Blogs Traffic",
                blogSubtitle: "Sorted by Views",
                demographicsTitle: "Top Demographics",
                tiles: null,
                layout: null,
                visibility: null,
                sizes: null,
                theme: cloneValue(DEFAULT_THEME)
            };

            const exportPayload = window.__EXPORT_MODE__ === DASHBOARD_TYPE ? window.__EXPORT_DATA__ : null;
            const isExport = Boolean(exportPayload);

            const DEFAULT_TILE_DATA = {
                kpis: { kpis: cloneValue(state.kpis || []) },
                bigStat: { value: state.bigStat ?? '', label: state.bigStatLabel ?? '' },
                highlights: { title: state.highlightTitle ?? 'Monthly Highlights', items: cloneValue(state.highlights || []) },
                blogs: {
                    title: state.blogTitle ?? 'New Monthly Blogs Traffic',
                    subtitle: state.blogSubtitle ?? 'Sorted by Views',
                    items: cloneValue(state.blogs || [])
                },
                graph: {
                    title: state.graph?.title ?? 'Traffic Trend',
                    subtitle: state.graph?.subtitle ?? 'Last 8 Weeks',
                    type: state.graph?.type ?? 'line',
                    series: cloneValue(state.graph?.series || [])
                },
                demographics: { title: state.demographicsTitle ?? 'Top Demographics', items: cloneValue(state.demographics || []) }
            };

            const TILE_TEMPLATE_IDS = {
                kpis: 'tile-template-kpis',
                bigStat: 'tile-template-bigStat',
                highlights: 'tile-template-highlights',
                blogs: 'tile-template-blogs',
                graph: 'tile-template-graph',
                demographics: 'tile-template-demographics'
            };

            let layoutEditing = false;
            let selectedTileId = null;
            let tileIdSeed = 1;

            function generateTileId() {
                tileIdSeed += 1;
                return `tile-${Date.now()}-${tileIdSeed}`;
            }

            function getDefaultTileSize(type) {
                const width = Number(state.theme?.preview?.width || 1100);
                const gap = Number(state.theme?.layout?.gap ?? 8);
                const leftWidth = Math.round(width * 0.45);
                const rightWidth = Math.max(320, width - leftWidth - gap);
                if (type === 'kpis') return { width, height: 120 };
                if (type === 'bigStat') return { width: leftWidth, height: 200 };
                if (type === 'highlights') return { width: leftWidth, height: 240 };
                if (type === 'blogs') return { width: rightWidth, height: 220 };
                if (type === 'graph') return { width: rightWidth, height: 220 };
                if (type === 'demographics') return { width: rightWidth, height: 140 };
                return { width: 360, height: 200 };
            }

            function createTileInstance(type, overrides = {}) {
                const size = getDefaultTileSize(type);
                const offset = (state.tiles?.length || 0) * 20;
                const base = {
                    id: generateTileId(),
                    type,
                    x: 20 + offset,
                    y: 20 + offset,
                    width: size.width,
                    height: size.height,
                    data: cloneValue(DEFAULT_TILE_DATA[type] || {})
                };
                const tile = { ...base, ...overrides };
                if (overrides.data) {
                    tile.data = cloneValue(overrides.data);
                }
                normalizeTileData(tile);
                return tile;
            }

            function buildDefaultTiles() {
                const width = Number(state.theme?.preview?.width || 1100);
                const gap = Number(state.theme?.layout?.gap ?? 8);
                const leftWidth = Math.round(width * 0.45);
                const rightWidth = Math.max(320, width - leftWidth - gap);
                const kpiHeight = 120;
                const bigStatHeight = 200;
                const highlightHeight = 240;
                const blogsHeight = 220;
                const graphHeight = 220;
                const demoHeight = 140;

                const yAfterKpi = kpiHeight + gap;
                const yAfterBigStat = yAfterKpi + bigStatHeight + gap;
                const yAfterHighlights = yAfterBigStat + highlightHeight + gap;
                const yAfterBlogs = yAfterKpi + blogsHeight + gap;
                const yAfterGraph = yAfterBlogs + graphHeight + gap;

                return [
                    {
                        id: generateTileId(),
                        type: 'kpis',
                        x: 0,
                        y: 0,
                        width,
                        height: kpiHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.kpis)
                    },
                    {
                        id: generateTileId(),
                        type: 'bigStat',
                        x: 0,
                        y: yAfterKpi,
                        width: leftWidth,
                        height: bigStatHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.bigStat)
                    },
                    {
                        id: generateTileId(),
                        type: 'highlights',
                        x: 0,
                        y: yAfterBigStat,
                        width: leftWidth,
                        height: highlightHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.highlights)
                    },
                    {
                        id: generateTileId(),
                        type: 'blogs',
                        x: leftWidth + gap,
                        y: yAfterKpi,
                        width: rightWidth,
                        height: blogsHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.blogs)
                    },
                    {
                        id: generateTileId(),
                        type: 'graph',
                        x: leftWidth + gap,
                        y: yAfterBlogs,
                        width: rightWidth,
                        height: graphHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.graph)
                    },
                    {
                        id: generateTileId(),
                        type: 'demographics',
                        x: leftWidth + gap,
                        y: yAfterGraph,
                        width: rightWidth,
                        height: demoHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.demographics)
                    }
                ];
            }

            function normalizeTileData(tile) {
                if (!tile.data || typeof tile.data !== 'object') {
                    tile.data = {};
                }
                const defaults = DEFAULT_TILE_DATA[tile.type];
                if (defaults) {
                    applyDefaults(tile.data, cloneValue(defaults));
                }

                if (tile.type === 'kpis') {
                    if (!Array.isArray(tile.data.kpis)) {
                        tile.data.kpis = cloneValue(DEFAULT_TILE_DATA.kpis.kpis);
                    }
                    normalizeKpiList(tile.data.kpis);
                }
                if (tile.type === 'highlights') {
                    if (!Array.isArray(tile.data.items)) {
                        tile.data.items = cloneValue(DEFAULT_TILE_DATA.highlights.items);
                    }
                }
                if (tile.type === 'blogs') {
                    if (!Array.isArray(tile.data.items)) {
                        tile.data.items = cloneValue(DEFAULT_TILE_DATA.blogs.items);
                    }
                }
                if (tile.type === 'demographics') {
                    if (!Array.isArray(tile.data.items)) {
                        tile.data.items = cloneValue(DEFAULT_TILE_DATA.demographics.items);
                    }
                }
                if (tile.type === 'graph') {
                    if (!Array.isArray(tile.data.series)) {
                        tile.data.series = cloneValue(DEFAULT_TILE_DATA.graph.series);
                    }
                }
            }

            function normalizeTilesState() {
                if (!Array.isArray(state.tiles) || state.tiles.length === 0) {
                    state.tiles = buildDefaultTiles();
                }

                state.tiles = state.tiles.filter(tile => tile && TILE_TEMPLATE_IDS[tile.type]);

                state.tiles.forEach(tile => {
                    if (!tile.id) tile.id = generateTileId();
                    tile.x = Math.max(0, Number(tile.x ?? 0));
                    tile.y = Math.max(0, Number(tile.y ?? 0));
                    tile.width = Math.max(180, Number(tile.width ?? 320));
                    tile.height = Math.max(120, Number(tile.height ?? 180));
                    normalizeTileData(tile);
                });

                if (!selectedTileId || !getTileById(selectedTileId)) {
                    selectedTileId = state.tiles[0]?.id || null;
                }
            }

            function getTileById(id) {
                return state.tiles.find(tile => tile.id === id);
            }

            function getTilesByType(type) {
                return state.tiles.filter(tile => tile.type === type);
            }

            function getSelectedTile() {
                return getTileById(selectedTileId) || state.tiles[0] || null;
            }

            function getActiveTile(type) {
                const selected = getSelectedTile();
                if (selected && selected.type === type) return selected;
                return state.tiles.find(tile => tile.type === type) || null;
            }

            function applyTilePosition(tile, node) {
                node.style.left = `${tile.x}px`;
                node.style.top = `${tile.y}px`;
                node.style.width = `${tile.width}px`;
                node.style.height = `${tile.height}px`;
            }

            function renderTileCanvas() {
                const canvas = document.getElementById('tile-canvas');
                if (!canvas) return;
                canvas.innerHTML = '';
                normalizeTilesState();

                state.tiles.forEach(tile => {
                    const templateId = TILE_TEMPLATE_IDS[tile.type];
                    const template = document.getElementById(templateId);
                    if (!template) return;
                    const node = template.content.firstElementChild.cloneNode(true);
                    node.dataset.tileId = tile.id;
                    node.dataset.tileType = tile.type;
                    applyTilePosition(tile, node);
                    canvas.appendChild(node);
                });
            }

            function setLayoutEditing(enabled) {
                layoutEditing = Boolean(enabled);
                document.body.classList.toggle('preview-editing', layoutEditing);
                const toggle = document.getElementById('preview-edit-toggle');
                if (toggle) {
                    toggle.textContent = layoutEditing ? 'Editing On' : 'Update Preview';
                }
            }

            function getCanvasSize() {
                const preview = document.getElementById('dashboard-preview');
                if (!preview) return { width: 0, height: 0 };
                return { width: preview.clientWidth, height: preview.clientHeight };
            }

            function getSnapTargets(excludeId) {
                return state.tiles
                    .filter(tile => tile.id !== excludeId)
                    .map(tile => ({
                        left: tile.x,
                        right: tile.x + tile.width,
                        top: tile.y,
                        bottom: tile.y + tile.height
                    }));
            }

            function snapPosition(value, size, axis, targets, canvasSize) {
                const threshold = 8;
                let snapped = value;
                const edges = [];
                targets.forEach(target => {
                    edges.push(axis === 'x' ? target.left : target.top);
                    edges.push(axis === 'x' ? target.right : target.bottom);
                });
                edges.push(0);
                edges.push(canvasSize);

                let minDiff = threshold;
                edges.forEach(edge => {
                    const startDiff = Math.abs(value - edge);
                    if (startDiff < minDiff) {
                        minDiff = startDiff;
                        snapped = edge;
                    }
                    const endDiff = Math.abs(value + size - edge);
                    if (endDiff < minDiff) {
                        minDiff = endDiff;
                        snapped = edge - size;
                    }
                });

                return snapToGrid(snapped);
            }

            function snapSize(value, start, axis, targets, canvasSize) {
                const threshold = 8;
                let snapped = value;
                const edges = [];
                targets.forEach(target => {
                    edges.push(axis === 'x' ? target.left : target.top);
                    edges.push(axis === 'x' ? target.right : target.bottom);
                });
                edges.push(canvasSize);

                let minDiff = threshold;
                edges.forEach(edge => {
                    const diff = Math.abs(start + value - edge);
                    if (diff < minDiff) {
                        minDiff = diff;
                        snapped = edge - start;
                    }
                });

                return snapToGrid(snapped);
            }

            function registerDragAndDrop() {
                const handles = document.querySelectorAll('.drag-handle');
                handles.forEach(handle => {
                    handle.addEventListener('pointerdown', (event) => {
                        if (!layoutEditing) return;
                        const card = handle.closest('.layout-card');
                        if (!card) return;
                        const tileId = card.dataset.tileId;
                        const tile = getTileById(tileId);
                        if (!tile) return;
                        const previousUserSelect = document.body.style.userSelect;
                        document.body.style.userSelect = 'none';
                        const pointerId = event.pointerId;
                        try {
                            handle.setPointerCapture(pointerId);
                        } catch (err) {
                            // ignore
                        }
                        const startX = event.clientX;
                        const startY = event.clientY;
                        const startLeft = tile.x;
                        const startTop = tile.y;
                        const targets = getSnapTargets(tileId);
                        const canvasSize = getCanvasSize();

                        const onMove = (moveEvent) => {
                            const dx = moveEvent.clientX - startX;
                            const dy = moveEvent.clientY - startY;
                            let nextLeft = startLeft + dx;
                            let nextTop = startTop + dy;
                            nextLeft = snapPosition(nextLeft, tile.width, 'x', targets, canvasSize.width);
                            nextTop = snapPosition(nextTop, tile.height, 'y', targets, canvasSize.height);
                            tile.x = Math.max(0, Math.min(nextLeft, canvasSize.width - tile.width));
                            tile.y = Math.max(0, Math.min(nextTop, canvasSize.height - tile.height));
                            applyTilePosition(tile, card);
                        };

                        const onUp = () => {
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            document.body.style.userSelect = previousUserSelect;
                            try {
                                handle.releasePointerCapture(pointerId);
                            } catch (err) {
                                // ignore
                            }
                            queueSaveDraft();
                        };

                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                        event.preventDefault();
                    });
                });
            }

            function registerResizeHandles() {
                const handles = document.querySelectorAll('.resize-handle');
                handles.forEach((handle) => {
                    handle.addEventListener('pointerdown', (event) => {
                        if (!layoutEditing) return;
                        const card = handle.closest('.layout-card');
                        if (!card) return;
                        const tileId = card.dataset.tileId;
                        const tile = getTileById(tileId);
                        if (!tile) return;
                        const previousUserSelect = document.body.style.userSelect;
                        document.body.style.userSelect = 'none';
                        const pointerId = event.pointerId;
                        try {
                            handle.setPointerCapture(pointerId);
                        } catch (err) {
                            // ignore
                        }
                        const startX = event.clientX;
                        const startY = event.clientY;
                        const startWidth = tile.width;
                        const startHeight = tile.height;
                        const targets = getSnapTargets(tileId);
                        const canvasSize = getCanvasSize();
                        const minWidth = 180;
                        const minHeight = 120;

                        const onMove = (moveEvent) => {
                            const dx = moveEvent.clientX - startX;
                            const dy = moveEvent.clientY - startY;
                            let nextWidth = Math.max(minWidth, startWidth + dx);
                            let nextHeight = Math.max(minHeight, startHeight + dy);
                            nextWidth = snapSize(nextWidth, tile.x, 'x', targets, canvasSize.width);
                            nextHeight = snapSize(nextHeight, tile.y, 'y', targets, canvasSize.height);
                            tile.width = Math.max(minWidth, nextWidth);
                            tile.height = Math.max(minHeight, nextHeight);
                            applyTilePosition(tile, card);
                        };

                        const onUp = () => {
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            document.body.style.userSelect = previousUserSelect;
                            try {
                                handle.releasePointerCapture(pointerId);
                            } catch (err) {
                                // ignore
                            }
                            queueSaveDraft();
                        };

                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                        event.preventDefault();
                    });
                });
            }

            function registerCanvasResize() {
                const handle = document.querySelector('.preview-resize-handle');
                const preview = document.getElementById('dashboard-preview');
                if (!handle || !preview) return;

                handle.addEventListener('pointerdown', (event) => {
                    if (!layoutEditing) return;
                    const previousUserSelect = document.body.style.userSelect;
                    document.body.style.userSelect = 'none';
                    const pointerId = event.pointerId;
                    try {
                        handle.setPointerCapture(pointerId);
                    } catch (err) {
                        // Ignore if pointer capture is not supported.
                    }
                    const startRect = preview.getBoundingClientRect();
                    const startX = event.clientX;
                    const startY = event.clientY;
                    const minWidth = 640;
                    const minHeight = 360;

                    const onMove = (moveEvent) => {
                        const dx = moveEvent.clientX - startX;
                        const dy = moveEvent.clientY - startY;
                        const nextWidth = Math.max(minWidth, startRect.width + dx);
                        const nextHeight = Math.max(minHeight, startRect.height + dy);
                        const snappedWidth = snapToGrid(nextWidth);
                        const snappedHeight = snapToGrid(nextHeight);
                        preview.style.setProperty('--preview-width', `${Math.round(snappedWidth)}px`);
                        preview.style.height = `${Math.round(snappedHeight)}px`;
                    };

                    const onUp = () => {
                        document.removeEventListener('pointermove', onMove);
                        document.removeEventListener('pointerup', onUp);
                        document.body.style.userSelect = previousUserSelect;
                        try {
                            handle.releasePointerCapture(pointerId);
                        } catch (err) {
                            // Ignore if pointer capture is not supported.
                        }
                        const finalRect = preview.getBoundingClientRect();
                        setByPath(state.theme, 'preview.width', Math.round(finalRect.width));
                        setByPath(state.theme, 'preview.height', Math.round(finalRect.height));
                        applyThemeToPreview(state);
                        queueSaveDraft();
                    };

                    document.addEventListener('pointermove', onMove);
                    document.addEventListener('pointerup', onUp);
                    event.preventDefault();
                });
            }

            function registerCanvasPanning() {
                const surface = document.querySelector('.canvas-surface');
                if (!surface) return;
                let isPanning = false;
                let startX = 0;
                let startY = 0;
                let startScrollLeft = 0;
                let startScrollTop = 0;
                let activePointerId = null;

                const shouldIgnoreTarget = (target) => {
                    if (!target) return false;
                    return Boolean(
                        target.closest('.layout-card') ||
                        target.closest('.preview-resize-handle') ||
                        target.closest('.resize-handle') ||
                        target.closest('input, textarea, select, button, a')
                    );
                };

                const onPointerDown = (event) => {
                    if (event.button !== 0) return;
                    if (shouldIgnoreTarget(event.target)) return;
                    isPanning = true;
                    activePointerId = event.pointerId;
                    startX = event.clientX;
                    startY = event.clientY;
                    startScrollLeft = surface.scrollLeft;
                    startScrollTop = surface.scrollTop;
                    surface.classList.add('is-panning');
                    try {
                        surface.setPointerCapture(activePointerId);
                    } catch (err) {
                        // ignore
                    }
                    event.preventDefault();
                };

                const onPointerMove = (event) => {
                    if (!isPanning) return;
                    const dx = event.clientX - startX;
                    const dy = event.clientY - startY;
                    surface.scrollLeft = startScrollLeft - dx;
                    surface.scrollTop = startScrollTop - dy;
                };

                const stopPanning = () => {
                    if (!isPanning) return;
                    isPanning = false;
                    surface.classList.remove('is-panning');
                    if (activePointerId !== null) {
                        try {
                            surface.releasePointerCapture(activePointerId);
                        } catch (err) {
                            // ignore
                        }
                    }
                    activePointerId = null;
                };

                surface.addEventListener('pointerdown', onPointerDown);
                surface.addEventListener('pointermove', onPointerMove);
                surface.addEventListener('pointerup', stopPanning);
                surface.addEventListener('pointerleave', stopPanning);
            }

            function registerInlineEditors() {
                const canvas = document.getElementById('tile-canvas');
                if (!canvas) return;
                canvas.addEventListener('keydown', (event) => {
                    const target = event.target;
                    if (event.key === 'Enter' && target && target.isContentEditable) {
                        event.preventDefault();
                        target.blur();
                    }
                });
                canvas.addEventListener('blur', (event) => {
                    const target = event.target;
                    if (!target || !target.isContentEditable) return;
                    const field = target.getAttribute('data-edit');
                    if (!field) return;
                    const card = target.closest('.layout-card');
                    if (!card) return;
                    const tileId = card.dataset.tileId;
                    const value = target.innerText.trim();
                    if (field === 'bigStat.value') {
                        updateBigStat(value, tileId);
                    } else if (field === 'bigStat.label') {
                        updateBigStatLabel(value, tileId);
                    } else if (field === 'highlights.title') {
                        updateHighlightTitle(value, tileId);
                    } else if (field === 'blogs.title') {
                        updateBlogsTitle(value, tileId);
                    } else if (field === 'blogs.subtitle') {
                        updateBlogsSubtitle(value, tileId);
                    } else if (field === 'graph.title') {
                        updateGraphTitle(value, tileId);
                    } else if (field === 'graph.subtitle') {
                        updateGraphSubtitle(value, tileId);
                    } else if (field === 'demographics.title') {
                        updateDemographicsTitle(value, tileId);
                    }
                }, true);
            }

            function registerTileSelection() {
                const preview = document.getElementById('dashboard-preview');
                if (!preview) return;
                preview.addEventListener('click', (event) => {
                    const actionButton = event.target.closest('[data-tile-action]');
                    if (actionButton) {
                        event.stopPropagation();
                        const action = actionButton.getAttribute('data-tile-action');
                        const card = actionButton.closest('.layout-card');
                        const tileId = card?.dataset.tileId;
                        if (!tileId) return;
                        if (action === 'edit') {
                            setSelectedTile(tileId);
                        } else if (action === 'duplicate') {
                            duplicateTile(tileId);
                        } else if (action === 'remove') {
                            removeTile(tileId);
                        }
                        return;
                    }
                    const card = event.target.closest('.layout-card');
                    if (card && layoutEditing) {
                        if (event.target.closest('button, input, textarea, select')) return;
                        setSelectedTile(card.dataset.tileId);
                    }
                });
            }

            let activeThemeGroup = THEME_CONTROL_GROUPS[0]?.title || 'Global';

            const TILE_TYPES = [
                { id: 'kpis', label: 'KPI Row' },
                { id: 'bigStat', label: 'Big Stat' },
                { id: 'highlights', label: 'Highlights' },
                { id: 'blogs', label: 'Blogs' },
                { id: 'graph', label: 'Graph' },
                { id: 'demographics', label: 'Demographics' }
            ];

            function updateTileSelectionDisplay() {
                const selected = getSelectedTile();
                if (!selected) return;
                selectedTileId = selected.id;
                document.querySelectorAll('.layout-card').forEach(card => {
                    card.classList.toggle('tile-selected', card.dataset.tileId === selected.id);
                });
                document.querySelectorAll('[data-tile-editor]').forEach(section => {
                    section.style.display = section.getAttribute('data-tile-editor') === selected.type ? '' : 'none';
                });
                document.querySelectorAll('[data-tile-instance]').forEach(row => {
                    row.classList.toggle('active', row.getAttribute('data-tile-instance') === selected.id);
                });
                const label = document.getElementById('selected-tile-label');
                if (label) {
                    const match = TILE_TYPES.find(tile => tile.id === selected.type);
                    label.textContent = match ? match.label : selected.type;
                }
            }

            function setSelectedTile(nextId) {
                if (!nextId) return;
                selectedTileId = nextId;
                updateTileSelectionDisplay();
            }

            function renderTileLibrary() {
                const container = document.getElementById('tile-type-list');
                if (!container) return;
                container.innerHTML = '';

                const addTitle = document.createElement('div');
                addTitle.className = 'tile-library-title';
                addTitle.textContent = 'Add Tiles';
                container.appendChild(addTitle);

                TILE_TYPES.forEach(tile => {
                    const row = document.createElement('div');
                    row.className = 'tile-library-item';
                    const label = document.createElement('div');
                    label.className = 'tile-library-label';
                    label.textContent = tile.label;

                    const action = document.createElement('button');
                    action.type = 'button';
                    action.className = 'tile-library-action';
                    action.textContent = 'Add';
                    action.addEventListener('click', (event) => {
                        event.stopPropagation();
                        addTile(tile.id);
                    });

                    row.appendChild(label);
                    row.appendChild(action);
                    container.appendChild(row);
                });

                const divider = document.createElement('div');
                divider.className = 'inspector-divider';
                container.appendChild(divider);

                const listTitle = document.createElement('div');
                listTitle.className = 'tile-library-title';
                listTitle.textContent = 'Tiles';
                container.appendChild(listTitle);

                const typeCounts = {};
                state.tiles.forEach(tile => {
                    typeCounts[tile.type] = (typeCounts[tile.type] || 0) + 1;
                    const row = document.createElement('div');
                    row.className = 'tile-library-item';
                    row.setAttribute('data-tile-instance', tile.id);
                    row.addEventListener('click', () => setSelectedTile(tile.id));

                    const label = document.createElement('div');
                    label.className = 'tile-library-label';
                    const typeMeta = TILE_TYPES.find(t => t.id === tile.type);
                    const name = typeMeta ? typeMeta.label : tile.type;
                    label.textContent = `${name} ${typeCounts[tile.type]}`;

                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'tile-library-action active';
                    removeBtn.textContent = 'Remove';
                    removeBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        removeTile(tile.id);
                    });

                    row.appendChild(label);
                    row.appendChild(removeBtn);
                    container.appendChild(row);
                });

                updateTileSelectionDisplay();
            }

            function renderBoxControls() {
                const quickContainer = document.getElementById('box-quick-controls');
                const themeContainer = document.getElementById('box-theme-controls');
                const previewToggle = document.getElementById('preview-edit-toggle');

                if (previewToggle) {
                    previewToggle.textContent = layoutEditing ? 'Editing On' : 'Update Preview';
                    previewToggle.onclick = () => setLayoutEditing(!layoutEditing);
                }

                if (quickContainer) {
                    quickContainer.innerHTML = '';

                    const fontRow = document.createElement('div');
                    fontRow.className = 'control-row';
                    const fontLabel = document.createElement('span');
                    fontLabel.textContent = 'Font';
                    const fontSelect = document.createElement('select');
                    FONT_CHOICES.forEach(choice => {
                        const option = document.createElement('option');
                        option.value = choice.value;
                        option.textContent = choice.label;
                        fontSelect.appendChild(option);
                    });
                    fontSelect.value = state.theme?.typography?.fontFamily || FONT_CHOICES[0].value;
                    fontSelect.addEventListener('change', () => {
                        setByPath(state.theme, 'typography.fontFamily', fontSelect.value);
                        applyThemeToPreview(state);
                        queueSaveDraft();
                    });
                    fontRow.appendChild(fontLabel);
                    fontRow.appendChild(fontSelect);
                    quickContainer.appendChild(fontRow);

                    [
                        { label: 'Preview Width', path: 'preview.width', min: 800, max: 1400, step: 10 },
                        { label: 'Preview Height', path: 'preview.height', min: 0, max: 1200, step: 10 },
                        { label: 'Preview Padding', path: 'preview.padding', min: 0, max: 16, step: 1 },
                        { label: 'Layout Gap', path: 'layout.gap', min: 0, max: 16, step: 1 },
                        { label: 'KPI Gap', path: 'layout.kpiGap', min: 0, max: 16, step: 1 }
                    ].forEach(control => {
                        const row = document.createElement('div');
                        row.className = 'control-row';
                        const label = document.createElement('span');
                        label.textContent = control.label;
                        const input = document.createElement('input');
                        input.type = 'range';
                        input.min = control.min;
                        input.max = control.max;
                        input.step = control.step;
                        const current = getByPath(state.theme, control.path);
                        input.value = current ?? control.min;
                        input.addEventListener('input', () => {
                            setByPath(state.theme, control.path, Number(input.value));
                            applyThemeToPreview(state);
                            queueSaveDraft();
                        });
                        row.appendChild(label);
                        row.appendChild(input);
                        quickContainer.appendChild(row);
                    });

                    const colorWrap = document.createElement('div');
                    colorWrap.className = 'space-y-2';
                    quickContainer.appendChild(colorWrap);
                    renderPreviewColorControls(colorWrap, state, () => {
                        applyThemeToPreview(state);
                        queueSaveDraft();
                    });
                }

                if (themeContainer) {
                    themeContainer.innerHTML = '';
                    const groupRow = document.createElement('div');
                    groupRow.className = 'control-row';
                    const groupLabel = document.createElement('span');
                    groupLabel.textContent = 'Theme Group';
                    const groupSelect = document.createElement('select');
                    THEME_CONTROL_GROUPS.forEach(group => {
                        const option = document.createElement('option');
                        option.value = group.title;
                        option.textContent = group.title;
                        groupSelect.appendChild(option);
                    });
                    groupSelect.value = activeThemeGroup;
                    groupSelect.addEventListener('change', () => {
                        activeThemeGroup = groupSelect.value;
                        renderBoxControls();
                    });
                    groupRow.appendChild(groupLabel);
                    groupRow.appendChild(groupSelect);
                    themeContainer.appendChild(groupRow);

                    const controlsBody = document.createElement('div');
                    controlsBody.className = 'space-y-2';
                    themeContainer.appendChild(controlsBody);
                    renderThemeControls(controlsBody, state, () => {
                        applyThemeToPreview(state);
                        renderAll();
                        queueSaveDraft();
                    }, activeThemeGroup);

                    const resetBtn = document.createElement('button');
                    resetBtn.type = 'button';
                    resetBtn.className = 'inspector-button';
                    resetBtn.textContent = 'Reset Theme';
                    resetBtn.addEventListener('click', () => {
                        state.theme = cloneValue(DEFAULT_THEME);
                        normalizeThemeState(state, DEFAULT_THEME);
                        applyThemeToPreview(state);
                        renderBoxControls();
                        queueSaveDraft();
                    });
                    themeContainer.appendChild(resetBtn);
                }
            }

            function renderTileStyleControls() {
                document.querySelectorAll('[data-style-group]').forEach((el) => {
                    const group = el.getAttribute('data-style-group');
                    if (!group) return;
                    renderThemeControls(el, state, () => {
                        applyThemeToPreview(state);
                        renderAll();
                        queueSaveDraft();
                    }, group);
                });
            }

            function renderInspectorControls() {
                const inspector = document.querySelector('.studio-inspector');
                if (isExport) {
                    if (inspector) inspector.style.display = 'none';
                    return;
                }
                if (inspector) inspector.style.display = 'flex';
                renderTileLibrary();
                renderBoxControls();
                renderTileStyleControls();
                updateTileSelectionDisplay();
            }

            function renderBigStat() {
                const tiles = getTilesByType('bigStat');
                tiles.forEach(tile => {
                    const node = document.querySelector(`.layout-card[data-tile-id=\"${tile.id}\"]`);
                    if (!node) return;
                    const valueEl = node.querySelector('[data-edit=\"bigStat.value\"]');
                    const labelEl = node.querySelector('[data-edit=\"bigStat.label\"]');
                    if (valueEl) valueEl.innerText = tile.data.value ?? '';
                    if (labelEl) labelEl.innerText = tile.data.label ?? '';
                });

                const active = getActiveTile('bigStat');
                if (!active) return;
                const input = document.getElementById('big-stat-input');
                const labelInput = document.getElementById('big-stat-label-input');
                if (input) input.value = active.data.value ?? '';
                if (labelInput) labelInput.value = active.data.label ?? '';
            }

            function renderKPIs() {
                const activeTile = getActiveTile('kpis');
                const inputContainer = document.getElementById('kpi-inputs');
                if (inputContainer) inputContainer.innerHTML = '';
                if (activeTile) {
                    normalizeKpiList(activeTile.data.kpis);
                    activeTile.data.kpis.forEach((kpi, i) => {
                        const div = document.createElement('div');
                        div.className = "section-group relative";
                        div.innerHTML = `
                            <div class=\"flex justify-between items-center mb-1\">
                                <label class=\"!mt-0 font-bold text-xs uppercase text-cyan-500\">KPI ${i + 1}</label>
                                <span onclick=\"removeItem('kpi', ${i}, '${activeTile.id}')\" class=\"remove-btn\">Remove</span>
                            </div>
                            <label class=\"!mt-0\">Title</label>
                            <input type=\"text\" value=\"${kpi.title}\" oninput=\"updateState('kpi', ${i}, 'title', this.value, '${activeTile.id}')\" class=\"mb-2\" placeholder=\"Title\">
                            <div class=\"grid grid-cols-2 gap-2\">
                                <div>
                                    <label class=\"!mt-0\">Prev</label>
                                    <input type=\"text\" value=\"${kpi.prev}\" oninput=\"updateState('kpi', ${i}, 'prev', this.value, '${activeTile.id}')\" placeholder=\"Prev\">
                                </div>
                                <div>
                                    <label class=\"!mt-0\">Curr</label>
                                    <input type=\"text\" value=\"${kpi.curr}\" oninput=\"updateState('kpi', ${i}, 'curr', this.value, '${activeTile.id}')\" placeholder=\"Curr\">
                                </div>
                            </div>
                            <label>Delta Override (optional)</label>
                            <input type=\"text\" value=\"${kpi.deltaOverride || ''}\" oninput=\"updateKpiDeltaOverride('${activeTile.id}', ${i}, this.value)\" placeholder=\"+10.5%\">
                            <div class=\"grid grid-cols-2 gap-2\">
                                <div>
                                    <label class=\"!mt-0\">Card From</label>
                                    <input type=\"color\" value=\"${kpi.theme?.from || getDefaultKpiTheme(i).from}\" oninput=\"updateKpiTheme('${activeTile.id}', ${i}, 'from', this.value)\">
                                </div>
                                <div>
                                    <label class=\"!mt-0\">Card To</label>
                                    <input type=\"color\" value=\"${kpi.theme?.to || getDefaultKpiTheme(i).to}\" oninput=\"updateKpiTheme('${activeTile.id}', ${i}, 'to', this.value)\">
                                </div>
                            </div>
                            <div class=\"grid grid-cols-2 gap-2\">
                                <div>
                                    <label class=\"!mt-0\">Title Color</label>
                                    <input type=\"color\" value=\"${kpi.theme?.titleColor || getDefaultKpiTheme(i).titleColor}\" oninput=\"updateKpiTheme('${activeTile.id}', ${i}, 'titleColor', this.value)\">
                                </div>
                                <div>
                                    <label class=\"!mt-0\">Value Color</label>
                                    <input type=\"color\" value=\"${kpi.theme?.valueColor || getDefaultKpiTheme(i).valueColor}\" oninput=\"updateKpiTheme('${activeTile.id}', ${i}, 'valueColor', this.value)\">
                                </div>
                            </div>
                        `;
                        if (inputContainer) inputContainer.appendChild(div);
                    });
                }
                const theme = state.theme || DEFAULT_THEME;
                getTilesByType('kpis').forEach(tile => {
                    const previewContainer = document.querySelector(`.layout-card[data-tile-id=\"${tile.id}\"] .kpi-preview-container`);
                    if (!previewContainer) return;
                    normalizeKpiList(tile.data.kpis);
                    previewContainer.innerHTML = '';
                    const colCount = Math.min(tile.data.kpis.length, 6) || 1;
                    previewContainer.style.gridTemplateColumns = `repeat(${colCount}, 1fr)`;

                    tile.data.kpis.forEach((kpi, i) => {
                        const prev = parseNumberLike(kpi.prev);
                        const curr = parseNumberLike(kpi.curr);
                        const deltaOverride = (kpi.deltaOverride || '').trim();

                        let pctText = "N/A";
                        let pctStyle = `background-color: ${applyAlpha(theme.kpi.deltaNeutralBg, theme.kpi.deltaNeutralOpacity)}; color: ${theme.kpi.deltaNeutralText};`;

                        if (deltaOverride) {
                            pctText = deltaOverride;
                            const sign = detectDeltaSign(deltaOverride);
                            if (sign > 0) {
                                pctStyle = `background-color: ${applyAlpha(theme.kpi.deltaPositiveBg, theme.kpi.deltaPositiveOpacity)}; color: ${theme.kpi.deltaPositiveText};`;
                            } else if (sign < 0) {
                                pctStyle = `background-color: ${applyAlpha(theme.kpi.deltaNegativeBg, theme.kpi.deltaNegativeOpacity)}; color: ${theme.kpi.deltaNegativeText};`;
                            }
                        } else if (prev.isNumeric && curr.isNumeric && prev.numeric !== 0) {
                            const change = ((curr.numeric - prev.numeric) / prev.numeric) * 100;
                            pctText = `${change > 0 ? "+" : ""}${change.toFixed(1)}%`;
                            pctStyle = change >= 0
                                ? `background-color: ${applyAlpha(theme.kpi.deltaPositiveBg, theme.kpi.deltaPositiveOpacity)}; color: ${theme.kpi.deltaPositiveText};`
                                : `background-color: ${applyAlpha(theme.kpi.deltaNegativeBg, theme.kpi.deltaNegativeOpacity)}; color: ${theme.kpi.deltaNegativeText};`;
                        }

                        const card = document.createElement('div');
                        card.className = "kpi-card";
                        const cardTheme = kpi.theme || getDefaultKpiTheme(i);
                        card.style.cssText = `background: linear-gradient(to bottom, ${applyAlpha(cardTheme.from, theme.effects?.kpiOpacity ?? 1)}, ${applyAlpha(cardTheme.to, theme.effects?.kpiOpacity ?? 1)}); padding: 16px; text-align: center; display: flex; flex-direction: column; justify-content: center; min-height: 80px;`;
                        card.innerHTML = `
                            <div class=\"kpi-title editable\" contenteditable=\"true\"
                                onkeydown=\"if(event.key==='Enter'){event.preventDefault(); this.blur();}\"
                                onblur=\"updateState('kpi', ${i}, 'title', this.innerText.trim(), '${tile.id}')\"
                                style=\"font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; opacity: 0.7; margin-bottom: 4px; color: ${cardTheme.titleColor || theme.kpi?.titleColor || '#111827'};\">${kpi.title}</div>
                            <div class=\"kpi-value editable\" contenteditable=\"true\"
                                onkeydown=\"if(event.key==='Enter'){event.preventDefault(); this.blur();}\"
                                onblur=\"updateKpiValue('${tile.id}', ${i}, this.innerText.trim())\"
                                style=\"font-size: 28px; font-weight: 800; line-height: 1; color: ${cardTheme.valueColor || theme.kpi?.valueColor || '#111827'};\">${formatNumberLike(kpi.curr)}</div>
                            <div style=\"margin-top: 6px;\">
                                <span class=\"kpi-delta editable\" contenteditable=\"true\"
                                    onkeydown=\"if(event.key==='Enter'){event.preventDefault(); this.blur();}\"
                                    onblur=\"updateKpiDeltaOverride('${tile.id}', ${i}, this.innerText.trim())\"
                                    style=\"font-size: 11px; font-weight: 700; padding: 2px 8px; border-radius: 4px; white-space: nowrap; ${pctStyle}\">${pctText}</span>
                            </div>
                        `;
                        previewContainer.appendChild(card);
                    });
                });
                applyThemeToPreview(state);
            }

            function renderHighlights() {
                const activeTile = getActiveTile('highlights');
                const inputContainer = document.getElementById('highlight-inputs');
                if (inputContainer) {
                    inputContainer.innerHTML = '';
                    if (activeTile) {
                        activeTile.data.items.forEach((text, i) => {
                            const div = document.createElement('div');
                            div.className = "section-group";
                            div.innerHTML = `
                                <div class="flex justify-between items-center mb-1">
                                    <label class="!mt-0">Point ${i + 1}</label>
                                    <span onclick="removeItem('highlight', ${i}, '${activeTile.id}')" class="remove-btn">Remove</span>
                                </div>
                                <textarea rows="2" oninput="updateState('highlight', ${i}, null, this.value, '${activeTile.id}')">${text}</textarea>
                            `;
                            inputContainer.appendChild(div);
                        });
                    }
                }

                getTilesByType('highlights').forEach(tile => {
                    const previewList = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] .highlight-preview-list`);
                    const titleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="highlights.title"]`);
                    if (titleDisplay) titleDisplay.innerText = tile.data.title ?? '';
                    if (!previewList) return;
                    previewList.innerHTML = '';
                    tile.data.items.forEach((text, i) => {
                        const row = document.createElement('div');
                        row.className = "flex items-start gap-3";
                        row.innerHTML = `
                            <span class="text-xl leading-none highlight-bullet" style="margin-top: -2px;">&bull;</span>
                            <span class="leading-relaxed highlight-text editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('highlight', ${i}, null, this.innerText.trim(), '${tile.id}')">${text}</span>
                        `;
                        previewList.appendChild(row);
                    });
                });

                const titleInput = document.getElementById('highlight-title-input');
                if (titleInput && activeTile) {
                    titleInput.value = activeTile.data.title ?? '';
                }
            }

            function renderBlogs() {
                const activeTile = getActiveTile('blogs');
                const inputContainer = document.getElementById('blog-inputs');
                if (inputContainer) {
                    inputContainer.innerHTML = '';
                    if (activeTile) {
                        activeTile.data.items.forEach((blog, i) => {
                            const div = document.createElement('div');
                            div.className = "section-group";
                            div.innerHTML = `
                                <div class="flex justify-between items-center mb-1">
                                    <label class="!mt-0 font-bold text-xs uppercase">Blog ${i + 1}</label>
                                    <span onclick="removeItem('blog', ${i}, '${activeTile.id}')" class="remove-btn">Remove</span>
                                </div>
                                <input type="text" value="${blog.title}" oninput="updateState('blog', ${i}, 'title', this.value, '${activeTile.id}')" class="mb-2" placeholder="Title">
                                <input type="text" value="${blog.views}" oninput="updateState('blog', ${i}, 'views', this.value, '${activeTile.id}')" placeholder="Views">
                            `;
                            inputContainer.appendChild(div);
                        });
                    }
                }

                getTilesByType('blogs').forEach(tile => {
                    const previewList = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] .blog-preview-list`);
                    const titleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="blogs.title"]`);
                    const subtitleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="blogs.subtitle"]`);
                    if (titleDisplay) titleDisplay.innerText = tile.data.title ?? '';
                    if (subtitleDisplay) subtitleDisplay.innerText = tile.data.subtitle ?? '';
                    if (!previewList) return;
                    previewList.innerHTML = '';
                    tile.data.items.forEach((blog, i) => {
                        const div = document.createElement('div');
                        div.className = `blog-row ${i % 2 === 0 ? 'even' : 'odd'}`;
                        div.style.cssText = "display: flex; justify-content: space-between; align-items: center; padding: 10px 12px;";
                        div.innerHTML = `
                            <span class="blog-title editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('blog', ${i}, 'title', this.innerText.trim(), '${tile.id}')"
                                style="font-weight: 600; font-size: 13px; line-height: 1.6;">${blog.title}</span>
                            <span class="blog-views editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('blog', ${i}, 'views', this.innerText.trim(), '${tile.id}')"
                                style="font-weight: 700; padding: 4px 8px; border-radius: 4px; font-size: 11px; white-space: nowrap; margin-left: 12px; flex-shrink: 0;">${blog.views}</span>
                        `;
                        previewList.appendChild(div);
                    });
                });

                const titleInput = document.getElementById('blogs-title-input');
                const subtitleInput = document.getElementById('blogs-subtitle-input');
                if (titleInput && activeTile) titleInput.value = activeTile.data.title ?? '';
                if (subtitleInput && activeTile) subtitleInput.value = activeTile.data.subtitle ?? '';
            }

            function renderGraph() {
                const activeTile = getActiveTile('graph');
                if (activeTile) {
                    const titleInput = document.getElementById('graph-title-input');
                    const subtitleInput = document.getElementById('graph-subtitle-input');
                    const typeInput = document.getElementById('graph-type-input');
                    if (titleInput) titleInput.value = activeTile.data.title || '';
                    if (subtitleInput) subtitleInput.value = activeTile.data.subtitle || '';
                    if (typeInput) typeInput.value = activeTile.data.type || 'line';

                    const inputContainer = document.getElementById('graph-inputs');
                    if (inputContainer) {
                        inputContainer.innerHTML = '';
                        activeTile.data.series.forEach((point, i) => {
                            const div = document.createElement('div');
                            div.className = 'section-group grid grid-cols-2 gap-2 items-end';
                            div.innerHTML = `
                                <div class="col-span-2 flex justify-between">
                                    <label class="!mt-0 font-bold text-xs">Point ${i + 1}</label>
                                    <span onclick="removeItem('graphPoint', ${i}, '${activeTile.id}')" class="remove-btn">Remove</span>
                                </div>
                                <input type="text" value="${point.label}" oninput="updateState('graphPoint', ${i}, 'label', this.value, '${activeTile.id}')" placeholder="Label">
                                <input type="text" value="${point.value}" oninput="updateState('graphPoint', ${i}, 'value', this.value, '${activeTile.id}')" placeholder="Value">
                            `;
                            inputContainer.appendChild(div);
                        });
                    }
                }

                getTilesByType('graph').forEach(tile => {
                    const svg = document.querySelector(`.layout-card[data-tile-id=\"${tile.id}\"] .graph-svg`);
                    const labels = document.querySelector(`.layout-card[data-tile-id=\"${tile.id}\"] .graph-labels`);
                    const titleDisplay = document.querySelector(`.layout-card[data-tile-id=\"${tile.id}\"] [data-edit=\"graph.title\"]`);
                    const subtitleDisplay = document.querySelector(`.layout-card[data-tile-id=\"${tile.id}\"] [data-edit=\"graph.subtitle\"]`);
                    if (titleDisplay) titleDisplay.innerText = tile.data.title || '';
                    if (subtitleDisplay) subtitleDisplay.innerText = tile.data.subtitle || '';
                    if (!svg) return;
                    const points = Array.isArray(tile.data.series) ? tile.data.series : [];
                    if (points.length === 0) {
                        svg.innerHTML = '';
                        if (labels) labels.innerHTML = '';
                        return;
                    }

                    const width = 300;
                    const height = 140;
                    const values = points.map(point => {
                        const parsed = parseNumberLike(point.value);
                        return parsed.isNumeric ? parsed.numeric : 0;
                    });
                    const maxValue = Math.max(...values, 1);
                    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

                    let svgMarkup = '';
                    for (let i = 1; i < 4; i += 1) {
                        const y = (height * i) / 4;
                        svgMarkup += `<line x1="0" y1="${y}" x2="${width}" y2="${y}" stroke="var(--graph-grid)" stroke-width="1" />`;
                    }

                    if (tile.data.type === 'bar') {
                        const slot = width / points.length;
                        const barWidth = Math.max(12, slot * 0.6);
                        points.forEach((point, i) => {
                            const value = values[i];
                            const barHeight = (value / maxValue) * height;
                            const x = i * slot + (slot - barWidth) / 2;
                            const y = height - barHeight;
                            svgMarkup += `<rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="var(--graph-line)" />`;
                        });
                    } else {
                        const step = points.length > 1 ? width / (points.length - 1) : width;
                        const coords = points.map((point, i) => {
                            const value = values[i];
                            const x = step * i;
                            const y = height - (value / maxValue) * height;
                            return { x, y };
                        });
                        const linePath = coords.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
                        const areaPath = `M 0 ${height} ${coords.map(p => `L ${p.x} ${p.y}`).join(' ')} L ${width} ${height} Z`;
                        svgMarkup += `<path d="${areaPath}" fill="var(--graph-fill)" />`;
                        svgMarkup += `<path d="${linePath}" fill="none" stroke="var(--graph-line)" stroke-width="2" />`;
                        coords.forEach((p) => {
                            svgMarkup += `<circle cx="${p.x}" cy="${p.y}" r="3" fill="var(--graph-point)" />`;
                        });
                    }

                    svg.innerHTML = svgMarkup;

                    if (labels) {
                        labels.innerHTML = '';
                        points.forEach((point) => {
                            const span = document.createElement('span');
                            span.textContent = point.label || '';
                            labels.appendChild(span);
                        });
                    }
                });
            }

            function renderDemographics() {
                const activeTile = getActiveTile('demographics');
                const inputContainer = document.getElementById('demo-inputs');
                if (inputContainer) {
                    inputContainer.innerHTML = '';
                    if (activeTile) {
                        activeTile.data.items.forEach((demo, i) => {
                            const div = document.createElement('div');
                            div.className = "section-group grid grid-cols-2 gap-2 items-end";
                            div.innerHTML = `
                                <div class=\"col-span-2 flex justify-between\">
                                     <label class=\"!mt-0 font-bold text-xs\">Region ${i + 1}</label>
                                     <span onclick=\"removeItem('demo', ${i}, '${activeTile.id}')\" class=\"remove-btn\">Remove</span>
                                </div>
                                <input type=\"text\" value=\"${demo.country}\" oninput=\"updateState('demo', ${i}, 'country', this.value, '${activeTile.id}')\" placeholder=\"Country\">
                                <input type=\"text\" value=\"${demo.val}\" oninput=\"updateState('demo', ${i}, 'val', this.value, '${activeTile.id}')\" placeholder=\"Value\">
                            `;
                            inputContainer.appendChild(div);
                        });
                    }
                }

                getTilesByType('demographics').forEach(tile => {
                    const previewGrid = document.querySelector(`.layout-card[data-tile-id=\"${tile.id}\"] .demo-grid`);
                    const titleDisplay = document.querySelector(`.layout-card[data-tile-id=\"${tile.id}\"] [data-edit=\"demographics.title\"]`);
                    if (titleDisplay) titleDisplay.innerText = tile.data.title ?? '';
                    if (!previewGrid) return;
                    previewGrid.innerHTML = '';
                    tile.data.items.forEach((demo, i) => {
                        const div = document.createElement('div');
                        div.className = "p-3";
                        div.innerHTML = `
                            <div class=\"demo-label editable\" contenteditable=\"true\"
                                onkeydown=\"if(event.key==='Enter'){event.preventDefault(); this.blur();}\"
                                onblur=\"updateState('demo', ${i}, 'country', this.innerText.trim(), '${tile.id}')\"
                                style=\"font-weight: 700; margin-bottom: 4px;\">${demo.country}</div>
                            <div class=\"demo-value editable\" contenteditable=\"true\"
                                onkeydown=\"if(event.key==='Enter'){event.preventDefault(); this.blur();}\"
                                onblur=\"updateState('demo', ${i}, 'val', this.innerText.trim(), '${tile.id}')\"
                                style=\"font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; font-weight: 700; font-size: 1.25rem;\">${demo.val}</div>
                        `;
                        previewGrid.appendChild(div);
                    });
                });

                const titleInput = document.getElementById('demographics-title-input');
                if (titleInput && activeTile) {
                    titleInput.value = activeTile.data.title ?? '';
                }
            }

            function updateState(type, index, field, value, tileId) {
                if (type === 'highlight') {
                    const resolved = resolveTileFromArgs('highlights', tileId, index);
                    if (!resolved.tile) return;
                    resolved.tile.data.items[resolved.index] = value;
                    renderHighlights();
                } else if (type === 'kpi') {
                    const resolved = resolveTileFromArgs('kpis', tileId, index);
                    if (!resolved.tile || !resolved.tile.data.kpis[resolved.index]) return;
                    resolved.tile.data.kpis[resolved.index][field] = value;
                    renderKPIs();
                } else if (type === 'blog') {
                    const resolved = resolveTileFromArgs('blogs', tileId, index);
                    if (!resolved.tile || !resolved.tile.data.items[resolved.index]) return;
                    resolved.tile.data.items[resolved.index][field] = value;
                    renderBlogs();
                } else if (type === 'demo') {
                    const resolved = resolveTileFromArgs('demographics', tileId, index);
                    if (!resolved.tile || !resolved.tile.data.items[resolved.index]) return;
                    resolved.tile.data.items[resolved.index][field] = value;
                    renderDemographics();
                } else if (type === 'graphPoint') {
                    const resolved = resolveTileFromArgs('graph', tileId, index);
                    if (!resolved.tile || !resolved.tile.data.series[resolved.index]) return;
                    resolved.tile.data.series[resolved.index][field] = value;
                    renderGraph();
                }
                queueSaveDraft();
            }

            function resolveTileFromArgs(type, tileId, index) {
                if (typeof tileId === 'string') {
                    return { tile: getTileById(tileId), index };
                }
                return { tile: getActiveTile(type), index: tileId };
            }

            function updateKpiValue(tileId, index, value) {
                const resolved = resolveTileFromArgs('kpis', tileId, index);
                if (!resolved.tile || !resolved.tile.data.kpis[resolved.index]) return;
                resolved.tile.data.kpis[resolved.index].curr = value;
                renderKPIs();
                queueSaveDraft();
            }

            function updateKpiDeltaOverride(tileId, index, value) {
                const resolved = resolveTileFromArgs('kpis', tileId, index);
                if (!resolved.tile || !resolved.tile.data.kpis[resolved.index]) return;
                resolved.tile.data.kpis[resolved.index].deltaOverride = value;
                renderKPIs();
                queueSaveDraft();
            }

            function updateKpiTheme(tileId, index, field, value) {
                const resolved = resolveTileFromArgs('kpis', tileId, index);
                if (!resolved.tile || !resolved.tile.data.kpis[resolved.index]) return;
                const kpi = resolved.tile.data.kpis[resolved.index];
                if (!kpi.theme || typeof kpi.theme !== 'object') {
                    kpi.theme = getDefaultKpiTheme(resolved.index);
                }
                kpi.theme[field] = value;
                applyThemeToPreview(state);
                renderKPIs();
                queueSaveDraft();
            }

            function addItem(type, tileId) {
                const resolved = resolveTileFromArgs(type === 'kpi' ? 'kpis' : type === 'demo' ? 'demographics' : type === 'graphPoint' ? 'graph' : type, tileId, 0);
                const tile = resolved.tile;
                if (!tile) return;
                if (type === 'kpi') {
                    const nextIndex = tile.data.kpis.length;
                    tile.data.kpis.push({ title: "New Metric", prev: "", curr: "", deltaOverride: "", theme: getDefaultKpiTheme(nextIndex) });
                    renderKPIs();
                } else if (type === 'highlight') {
                    tile.data.items.push("New highlight point...");
                    renderHighlights();
                } else if (type === 'blog') {
                    tile.data.items.push({ title: "New Blog Post", url: "#", views: "0.0K" });
                    renderBlogs();
                } else if (type === 'demo') {
                    tile.data.items.push({ country: "Region", val: "0.0K" });
                    renderDemographics();
                } else if (type === 'graphPoint') {
                    tile.data.series.push({ label: `P${tile.data.series.length + 1}`, value: "0" });
                    renderGraph();
                }
                queueSaveDraft();
            }

            function removeItem(type, index, tileId) {
                if (!confirm("Are you sure you want to remove this item?")) return;
                const resolved = resolveTileFromArgs(type === 'kpi' ? 'kpis' : type === 'demo' ? 'demographics' : type === 'graphPoint' ? 'graph' : type, tileId, index);
                const tile = resolved.tile;
                if (!tile) return;
                if (type === 'kpi') tile.data.kpis.splice(resolved.index, 1);
                if (type === 'highlight') tile.data.items.splice(resolved.index, 1);
                if (type === 'blog') tile.data.items.splice(resolved.index, 1);
                if (type === 'demo') tile.data.items.splice(resolved.index, 1);
                if (type === 'graphPoint') tile.data.series.splice(resolved.index, 1);
                renderAll();
                queueSaveDraft();
            }

            function updateBigStat(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('bigStat');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('big-stat-input')?.value || '';
                tile.data.value = nextValue;
                renderBigStat();
                queueSaveDraft();
            }

            function updateBigStatLabel(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('bigStat');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('big-stat-label-input')?.value || '';
                tile.data.label = nextValue;
                renderBigStat();
                queueSaveDraft();
            }

            function updateHighlightTitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('highlights');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('highlight-title-input')?.value || '';
                tile.data.title = nextValue;
                renderHighlights();
                queueSaveDraft();
            }

            function updateBlogsTitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('blogs');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('blogs-title-input')?.value || '';
                tile.data.title = nextValue;
                renderBlogs();
                queueSaveDraft();
            }

            function updateBlogsSubtitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('blogs');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('blogs-subtitle-input')?.value || '';
                tile.data.subtitle = nextValue;
                renderBlogs();
                queueSaveDraft();
            }

            function updateDemographicsTitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('demographics');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('demographics-title-input')?.value || '';
                tile.data.title = nextValue;
                renderDemographics();
                queueSaveDraft();
            }

            function updateGraphTitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('graph');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('graph-title-input')?.value || '';
                tile.data.title = nextValue;
                renderGraph();
                queueSaveDraft();
            }

            function updateGraphSubtitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('graph');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('graph-subtitle-input')?.value || '';
                tile.data.subtitle = nextValue;
                renderGraph();
                queueSaveDraft();
            }

            function updateGraphType(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('graph');
                if (!tile) return;
                tile.data.type = value;
                renderGraph();
                queueSaveDraft();
            }

            function addTile(type) {
                const tile = createTileInstance(type);
                state.tiles.push(tile);
                selectedTileId = tile.id;
                renderAll();
                queueSaveDraft();
            }

            function duplicateTile(tileId) {
                const tile = getTileById(tileId);
                if (!tile) return;
                const clone = createTileInstance(tile.type, {
                    x: tile.x + 20,
                    y: tile.y + 20,
                    width: tile.width,
                    height: tile.height,
                    data: cloneValue(tile.data)
                });
                state.tiles.push(clone);
                selectedTileId = clone.id;
                renderAll();
                queueSaveDraft();
            }

            function removeTile(tileId) {
                const index = state.tiles.findIndex(tile => tile.id === tileId);
                if (index === -1) return;
                state.tiles.splice(index, 1);
                if (selectedTileId === tileId) {
                    selectedTileId = state.tiles[0]?.id || null;
                }
                renderAll();
                queueSaveDraft();
            }

            function normalizeMonthlyState() {
                if (state.schemaVersion === undefined || state.schemaVersion === null) {
                    state.schemaVersion = 2;
                }

                normalizeThemeState(state, DEFAULT_THEME);

                if (!Array.isArray(state.tiles) || state.tiles.length === 0) {
                    state.tiles = buildDefaultTiles();
                }
                normalizeTilesState();

                const kpiTile = getTilesByType('kpis')[0];
                if (kpiTile && Array.isArray(state.kpis) && state.kpis.length) {
                    kpiTile.data.kpis = cloneValue(state.kpis);
                    normalizeKpiList(kpiTile.data.kpis);
                }
                const highlightsTile = getTilesByType('highlights')[0];
                if (highlightsTile && Array.isArray(state.highlights) && state.highlights.length) {
                    highlightsTile.data.items = cloneValue(state.highlights);
                }
                if (highlightsTile && state.highlightTitle) {
                    highlightsTile.data.title = state.highlightTitle;
                }
                const blogsTile = getTilesByType('blogs')[0];
                if (blogsTile && Array.isArray(state.blogs) && state.blogs.length) {
                    blogsTile.data.items = cloneValue(state.blogs);
                }
                if (blogsTile && state.blogTitle) blogsTile.data.title = state.blogTitle;
                if (blogsTile && state.blogSubtitle) blogsTile.data.subtitle = state.blogSubtitle;
                const demoTile = getTilesByType('demographics')[0];
                if (demoTile && Array.isArray(state.demographics) && state.demographics.length) {
                    demoTile.data.items = cloneValue(state.demographics);
                }
                if (demoTile && state.demographicsTitle) demoTile.data.title = state.demographicsTitle;
                const graphTile = getTilesByType('graph')[0];
                if (graphTile && state.graph && typeof state.graph === 'object') {
                    graphTile.data.title = state.graph.title || graphTile.data.title;
                    graphTile.data.subtitle = state.graph.subtitle || graphTile.data.subtitle;
                    graphTile.data.type = state.graph.type || graphTile.data.type;
                    if (Array.isArray(state.graph.series) && state.graph.series.length) {
                        graphTile.data.series = cloneValue(state.graph.series);
                    }
                }
                const bigStatTile = getTilesByType('bigStat')[0];
                if (bigStatTile && state.bigStat !== undefined) bigStatTile.data.value = String(state.bigStat);
                if (bigStatTile && state.bigStatLabel) bigStatTile.data.label = state.bigStatLabel;
            }

            function buildJsonTemplate() {
                const width = DEFAULT_THEME.preview?.width || 1100;
                const gap = DEFAULT_THEME.layout?.gap ?? 8;
                const leftWidth = Math.round(width * 0.45);
                const rightWidth = Math.max(320, width - leftWidth - gap);
                return {
                    mode: DASHBOARD_TYPE,
                    data: {
                        schemaVersion: 2,
                        theme: cloneValue(DEFAULT_THEME),
                        tiles: [
                            {
                                id: "tile-1",
                                type: "kpis",
                                x: 0,
                                y: 0,
                                width,
                                height: 120,
                                data: {
                                    kpis: [
                                        {
                                            title: "Active Users",
                                            prev: "3800",
                                            curr: "4200",
                                            deltaOverride: "",
                                            theme: getDefaultKpiTheme(0)
                                        }
                                    ]
                                }
                            },
                            {
                                id: "tile-2",
                                type: "bigStat",
                                x: 0,
                                y: 132,
                                width: leftWidth,
                                height: 200,
                                data: {
                                    value: "13",
                                    label: "Total Blogs Released"
                                }
                            },
                            {
                                id: "tile-3",
                                type: "highlights",
                                x: 0,
                                y: 344,
                                width: leftWidth,
                                height: 240,
                                data: {
                                    title: "Monthly Highlights",
                                    items: [
                                        "Highlight one",
                                        "Highlight two"
                                    ]
                                }
                            },
                            {
                                id: "tile-4",
                                type: "blogs",
                                x: leftWidth + gap,
                                y: 132,
                                width: rightWidth,
                                height: 220,
                                data: {
                                    title: "New Monthly Blogs Traffic",
                                    subtitle: "Sorted by Views",
                                    items: [
                                        { title: "Your Blog Title", views: "6.5K" }
                                    ]
                                }
                            },
                            {
                                id: "tile-5",
                                type: "graph",
                                x: leftWidth + gap,
                                y: 364,
                                width: rightWidth,
                                height: 220,
                                data: {
                                    title: "Traffic Trend",
                                    subtitle: "Last 8 Weeks",
                                    type: "line",
                                    series: [
                                        { label: "W1", value: "120" },
                                        { label: "W2", value: "160" },
                                        { label: "W3", value: "140" },
                                        { label: "W4", value: "210" },
                                        { label: "W5", value: "180" },
                                        { label: "W6", value: "240" }
                                    ]
                                }
                            },
                            {
                                id: "tile-6",
                                type: "demographics",
                                x: leftWidth + gap,
                                y: 596,
                                width: rightWidth,
                                height: 140,
                                data: {
                                    title: "Top Demographics",
                                    items: [
                                        { country: "Region", val: "3.8K" }
                                    ]
                                }
                            }
                        ]
                    }
                };
            }

            function applyJson() {
                const input = document.getElementById('json-input');
                if (!input || !input.value.trim()) {
                    alert('Paste JSON first.');
                    return;
                }
                try {
                    const payload = JSON.parse(input.value);
                    if (payload && payload.mode && payload.mode !== DASHBOARD_TYPE) {
                        alert(`This JSON is for \"${payload.mode}\" mode. Switch modes and try again.`);
                        return;
                    }
                    const data = payload && payload.data && typeof payload.data === 'object' ? payload.data : payload;
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid JSON');
                    }
                    state = JSON.parse(JSON.stringify(data));
                    normalizeMonthlyState();
                    renderAll();
                    renderInspectorControls();
                    queueSaveDraft();
                } catch (err) {
                    console.error('JSON apply failed:', err);
                    alert('Invalid JSON. Please check the format.');
                }
            }

            async function copyJson() {
                const payload = { mode: DASHBOARD_TYPE, data: getSerializableState() };
                const text = JSON.stringify(payload, null, 2);
                const input = document.getElementById('json-input');
                if (input) input.value = text;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    try {
                        await navigator.clipboard.writeText(text);
                    } catch (err) {
                        console.warn('Clipboard copy failed:', err);
                    }
                } else if (input) {
                    input.select();
                    document.execCommand('copy');
                }
            }

            async function copyJsonTemplate() {
                const payload = buildJsonTemplate();
                const text = JSON.stringify(payload, null, 2);
                const input = document.getElementById('json-input');
                if (input) input.value = text;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    try {
                        await navigator.clipboard.writeText(text);
                    } catch (err) {
                        console.warn('Clipboard copy failed:', err);
                    }
                } else if (input) {
                    input.select();
                    document.execCommand('copy');
                }
            }

            function loadJsonFile(file) {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = () => {
                    const input = document.getElementById('json-input');
                    if (input) input.value = reader.result;
                    applyJson();
                };
                reader.readAsText(file);
            }

            async function loadDashboard() {
                if (isExport && exportPayload) {
                    state = JSON.parse(JSON.stringify(exportPayload));
                    normalizeMonthlyState();
                    return;
                }
                try {
                    const res = await fetch(`/api/dashboards?type=${encodeURIComponent(DASHBOARD_TYPE)}`);
                    if (!res.ok) throw new Error(`Failed to load dashboard (${res.status})`);
                    const payload = await res.json();
                    dashboardId = payload.dashboard.id;
                    if (payload.dashboard.data && typeof payload.dashboard.data === 'object') {
                        state = payload.dashboard.data;
                    }
                    normalizeMonthlyState();
                } catch (err) {
                    console.error('Load dashboard failed:', err);
                }
            }

            async function saveDraft() {
                if (isExport) return;
                if (!dashboardId) return;
                try {
                    await fetch(`/api/dashboards/${dashboardId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ data: getSerializableState() })
                    });
                } catch (err) {
                    console.error('Auto-save failed:', err);
                }
            }

            function queueSaveDraft() {
                if (isExport) return;
                if (!dashboardId) return;
                if (saveTimer) clearTimeout(saveTimer);
                saveTimer = setTimeout(saveDraft, 600);
            }

            async function saveState() {
                if (!dashboardId) return alert('Server not ready yet.');
                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ data: getSerializableState() })
                    });
                    if (!res.ok) throw new Error(`Save failed (${res.status})`);
                    await renderHistory();
                    alert('State saved successfully!');
                } catch (err) {
                    console.error('Save state failed:', err);
                    alert('Save failed. Check console for details.');
                }
            }

            async function loadState(versionId) {
                if (!confirm("Load this state? Current unsaved changes will be lost.")) return;
                if (!dashboardId) return;
                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions/${versionId}`);
                    if (!res.ok) throw new Error(`Load failed (${res.status})`);
                    const payload = await res.json();
                    if (payload.data && typeof payload.data === 'object') {
                        state = payload.data;
                        renderAll();
                        queueSaveDraft();
                    }
                } catch (err) {
                    console.error('Load state failed:', err);
                    alert('Load failed. Check console for details.');
                }
            }

            async function deleteState(versionId) {
                if (!confirm("Delete this saved state?")) return;
                if (!dashboardId) return;
                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions/${versionId}`, {
                        method: 'DELETE'
                    });
                    if (!res.ok) throw new Error(`Delete failed (${res.status})`);
                    await renderHistory();
                } catch (err) {
                    console.error('Delete state failed:', err);
                    alert('Delete failed. Check console for details.');
                }
            }

            async function clearHistory() {
                if (!confirm("Clear all history?")) return;
                if (!dashboardId) return;
                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions`, {
                        method: 'DELETE'
                    });
                    if (!res.ok) throw new Error(`Clear failed (${res.status})`);
                    await renderHistory();
                } catch (err) {
                    console.error('Clear history failed:', err);
                    alert('Clear failed. Check console for details.');
                }
            }

            async function renderHistory() {
                const list = document.getElementById('history-list');
                if (!list) return;

                if (!dashboardId) {
                    list.innerHTML = '<div class="italic opacity-50 p-2 text-center">Loading...</div>';
                    return;
                }

                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions`);
                    if (!res.ok) throw new Error(`History failed (${res.status})`);
                    const payload = await res.json();
                    const history = payload.versions || [];

                    list.innerHTML = '';
                    if (history.length === 0) {
                        list.innerHTML = '<div class="italic opacity-50 p-2 text-center">No saved states</div>';
                        return;
                    }

                    history.forEach((item, i) => {
                        const div = document.createElement('div');
                        const stamp = item.createdAt ? new Date(item.createdAt).toLocaleString() : '';
                        div.className = "flex justify-between items-center bg-gray-800 p-2 rounded border border-gray-700 hover:border-gray-500 transition-colors group";
                        div.innerHTML = `
                            <div class="cursor-pointer flex-1" onclick="loadState(${item.id})">
                                <div class="font-bold text-gray-300 group-hover:text-cyan-400">Save #${history.length - i}</div>
                                <div class="text-[10px] opacity-70">${stamp}</div>
                            </div>
                            <button onclick="deleteState(${item.id})" class="text-gray-600 hover:text-red-500 ml-2 px-1" title="Delete"></button>
                        `;
                        list.appendChild(div);
                    });
                } catch (err) {
                    console.error('Render history failed:', err);
                    list.innerHTML = '<div class="italic opacity-50 p-2 text-center">Failed to load history</div>';
                }
            }

            function renderAll() {
                renderTileCanvas();
                renderBigStat();
                renderKPIs();
                renderHighlights();
                renderBlogs();
                renderGraph();
                renderDemographics();
                applyThemeToPreview(state);
                updateTileSelectionDisplay();
                registerDragAndDrop();
                registerResizeHandles();
            }

            function prepareExport() {
                normalizeTilesState();
                const preview = document.getElementById('dashboard-preview');
                if (!preview) return null;
                const styles = getComputedStyle(preview);
                const paddingX = (parseFloat(styles.paddingLeft) || 0) + (parseFloat(styles.paddingRight) || 0);
                const paddingY = (parseFloat(styles.paddingTop) || 0) + (parseFloat(styles.paddingBottom) || 0);
                const contentWidth = Math.max(0, preview.clientWidth - paddingX);
                const contentHeight = Math.max(0, preview.clientHeight - paddingY);
                const margin = 16;
                let maxRight = 0;
                let maxBottom = 0;
                state.tiles.forEach(tile => {
                    const right = Number(tile.x || 0) + Number(tile.width || 0);
                    const bottom = Number(tile.y || 0) + Number(tile.height || 0);
                    maxRight = Math.max(maxRight, right);
                    maxBottom = Math.max(maxBottom, bottom);
                });
                const nextWidth = Math.max(contentWidth, maxRight) + paddingX + margin;
                const nextHeight = Math.max(contentHeight, maxBottom) + paddingY + margin;
                preview.style.setProperty('--preview-width', `${Math.ceil(nextWidth)}px`);
                preview.style.height = `${Math.ceil(nextHeight)}px`;
                return { width: Math.ceil(nextWidth), height: Math.ceil(nextHeight) };
            }

            function getSerializableState() {
                normalizeTilesState();
                return {
                    schemaVersion: state.schemaVersion ?? 2,
                    theme: cloneValue(state.theme || DEFAULT_THEME),
                    tiles: cloneValue(state.tiles || [])
                };
            }

            async function exportFromServer(format) {
                try {
                    if (window.location.protocol === 'file:') {
                        alert('Exports require the app to run on http://localhost:3000. Please start the server and reload.');
                        return;
                    }
                    const payload = {
                        mode: DASHBOARD_TYPE,
                        format,
                        data: getSerializableState()
                    };

                    const res = await fetch('/api/export', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(errorText || `Export failed (${res.status})`);
                    }

                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = format === 'pdf' ? 'monthly-update.pdf' : 'monthly-update.png';
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                } catch (err) {
                    console.error('Export failed:', err);
                    alert('Export failed. Check console for details.');
                }
            }

            function downloadPNG() {
                exportFromServer('png');
            }

            function downloadPDF() {
                exportFromServer('pdf');
            }

            function bindGlobals() {
                cleanupGlobals = exposeHandlers({
                    saveState,
                    clearHistory,
                    addItem,
                    removeItem,
                    updateState,
                    updateKpiValue,
                    updateKpiDeltaOverride,
                    updateKpiTheme,
                    updateBigStat,
                    updateBigStatLabel,
                    updateHighlightTitle,
                    updateBlogsTitle,
                    updateBlogsSubtitle,
                    updateDemographicsTitle,
                    updateGraphTitle,
                    updateGraphSubtitle,
                    updateGraphType,
                    applyJson,
                    copyJson,
                    copyJsonTemplate,
                    loadJsonFile,
                    downloadPNG,
                    downloadPDF,
                    loadState,
                    deleteState,
                    setLayoutEditing
                });
            }

            async function init() {
                bindGlobals();
                await loadDashboard();
                renderAll();
                window.__prepareExport__ = prepareExport;
                if (isExport) {
                    document.body.classList.add('export-mode');
                    const inspector = document.querySelector('.studio-inspector');
                    if (inspector) inspector.style.display = 'none';
                    window.__EXPORT_READY__ = true;
                    return;
                }
                renderInspectorControls();
                registerDragAndDrop();
                registerResizeHandles();
                registerCanvasResize();
                registerCanvasPanning();
                registerInlineEditors();
                registerTileSelection();
                setLayoutEditing(false);
                queueSaveDraft();
            }

            init();

            return {
                destroy() {
                    if (saveTimer) clearTimeout(saveTimer);
                    if (cleanupGlobals) cleanupGlobals();
                }
            };
        }

        function initYearlyApp() {
            const DASHBOARD_TYPE = 'yearly';
            let dashboardId = null;
            let saveTimer = null;
            let cleanupGlobals = null;

            let state = {
                schemaVersion: 2,
                highlightTitle: "Yearly Highlights",
                kpis: [
                    { title: "Active Users", prev: 33832, curr: 123883 },
                    { title: "Total Sessions", prev: 63776, curr: 306557 },
                    { title: "Page Views", prev: 77433, curr: 362412 },
                    { title: "Content Count", prev: 109, curr: 290 }
                ],
                highlights: [
                    "Explosive Growth: Blogs saw +266% active user growth and +380% session growth, exceeding expectations.",
                    "Day 0 Strategy: Content aligned with major AI releases (OpenAI, DeepSeek, Qwen) dominated top rankings.",
                    "SEO Success: Organic Search remains dominant (48% of traffic) with +162% YoY growth.",
                    "AI Indexing: Emerging traffic from LLM search tools (Perplexity, ChatGPT) grew over 1,000%.",
                    "Global Reach: Strong expansion in APAC region significantly broadened developer mindshare.",
                    "Content Scale: Library expanded +166% to 290 blogs, building a robust developer resource foundation."
                ],
                blogs: [
                    { title: "Day 0 Guide: OpenAI Models on AMD", views: "13,672" },
                    { title: "Power Up Qwen 3 with AMD Instinct", views: "11,234" },
                    { title: "Supercharge DeepSeek-R1 Inference", views: "10,104" },
                    { title: "Unlock DeepSeek-R1 Perf on MI300X", views: "10,015" },
                    { title: "Running ComfyUI on Windows/ROCm", views: "8,354" },
                    { title: "Introducing Instella: Open 3B Models", views: "8,021" },
                    { title: "AITER: AI Tensor Engine For ROCm", views: "7,821" },
                    { title: "Deep Dive into MI300 Partition Modes", views: "7,511" },
                    { title: "SGLang: Fast Serving Framework", views: "6,337" },
                    { title: "Understanding Peak & Delivered FLOPS", views: "5,252" }
                ],
                demographics: [
                    { country: "Organic Search", val: "48.0%" },
                    { country: "Direct", val: "30.1%" },
                    { country: "Organic Social", val: "11.7%" },
                    { country: "Referral", val: "8.4%" },
                    { country: "Organic Video", val: "0.5%" },
                    { country: "Email", val: "0.3%" }
                ],
                graph: {
                    title: "Monthly Growth",
                    subtitle: "2025",
                    type: "line",
                    series: [
                        { label: "Jan", value: "1200" },
                        { label: "Feb", value: "1450" },
                        { label: "Mar", value: "1380" },
                        { label: "Apr", value: "1620" },
                        { label: "May", value: "1750" },
                        { label: "Jun", value: "1920" }
                    ]
                },
                blogTitle: "Top Performing Content (2025)",
                blogSubtitle: "Sorted by Views",
                demographicsTitle: "Traffic Acquisition",
                bigStat: { label: "Blogs Released in 2025", value: "181" },
                tiles: null,
                layout: null,
                visibility: null,
                sizes: null,
                theme: cloneValue(YEARLY_THEME_DEFAULTS)
            };

            const exportPayload = window.__EXPORT_MODE__ === DASHBOARD_TYPE ? window.__EXPORT_DATA__ : null;
            const isExport = Boolean(exportPayload);

            const DEFAULT_TILE_DATA = {
                kpis: { kpis: cloneValue(state.kpis || []) },
                bigStat: {
                    value: state.bigStat?.value ?? '181',
                    label: state.bigStat?.label ?? 'Blogs Released in 2025'
                },
                highlights: { title: state.highlightTitle ?? 'Yearly Highlights', items: cloneValue(state.highlights || []) },
                blogs: {
                    title: state.blogTitle ?? 'Top Performing Content (2025)',
                    subtitle: state.blogSubtitle ?? 'Sorted by Views',
                    items: cloneValue(state.blogs || [])
                },
                graph: {
                    title: state.graph?.title ?? 'Monthly Growth',
                    subtitle: state.graph?.subtitle ?? '2025',
                    type: state.graph?.type ?? 'line',
                    series: cloneValue(state.graph?.series || [])
                },
                demographics: { title: state.demographicsTitle ?? 'Traffic Acquisition', items: cloneValue(state.demographics || []) }
            };

            const DEFAULT_LAYOUT = {
                kpi: ['kpis'],
                left: ['bigStat', 'highlights'],
                right: ['blogs', 'graph', 'demographics']
            };

            const DEFAULT_VISIBILITY = {
                kpis: true,
                bigStat: true,
                highlights: true,
                blogs: true,
                graph: true,
                demographics: true
            };

            const TILE_TEMPLATE_IDS = {
                kpis: 'tile-template-kpis',
                bigStat: 'tile-template-bigStat',
                highlights: 'tile-template-highlights',
                blogs: 'tile-template-blogs',
                graph: 'tile-template-graph',
                demographics: 'tile-template-demographics'
            };

            let layoutEditing = false;
            let selectedTileId = null;
            let tileIdSeed = 1;

            function generateTileId() {
                tileIdSeed += 1;
                return `tile-${Date.now()}-${tileIdSeed}`;
            }

            function getDefaultTileSize(type) {
                const width = Number(state.theme?.preview?.width || 1100);
                const gap = Number(state.theme?.layout?.gap ?? 8);
                const leftWidth = Math.round(width * 0.45);
                const rightWidth = Math.max(320, width - leftWidth - gap);
                if (type === 'kpis') return { width, height: 120 };
                if (type === 'bigStat') return { width: leftWidth, height: 200 };
                if (type === 'highlights') return { width: leftWidth, height: 240 };
                if (type === 'blogs') return { width: rightWidth, height: 220 };
                if (type === 'graph') return { width: rightWidth, height: 220 };
                if (type === 'demographics') return { width: rightWidth, height: 140 };
                return { width: 360, height: 200 };
            }

            function createTileInstance(type, overrides = {}) {
                const size = getDefaultTileSize(type);
                const offset = (state.tiles?.length || 0) * 20;
                const base = {
                    id: generateTileId(),
                    type,
                    x: 20 + offset,
                    y: 20 + offset,
                    width: size.width,
                    height: size.height,
                    data: cloneValue(DEFAULT_TILE_DATA[type] || {})
                };
                const tile = { ...base, ...overrides };
                if (overrides.data) {
                    tile.data = cloneValue(overrides.data);
                }
                normalizeTileData(tile);
                return tile;
            }

            function buildDefaultTiles() {
                const width = Number(state.theme?.preview?.width || 1100);
                const gap = Number(state.theme?.layout?.gap ?? 8);
                const leftWidth = Math.round(width * 0.45);
                const rightWidth = Math.max(320, width - leftWidth - gap);
                const kpiHeight = 120;
                const bigStatHeight = 200;
                const highlightHeight = 240;
                const blogsHeight = 220;
                const graphHeight = 220;
                const demoHeight = 140;

                const yAfterKpi = kpiHeight + gap;
                const yAfterBigStat = yAfterKpi + bigStatHeight + gap;
                const yAfterHighlights = yAfterBigStat + highlightHeight + gap;
                const yAfterBlogs = yAfterKpi + blogsHeight + gap;
                const yAfterGraph = yAfterBlogs + graphHeight + gap;

                return [
                    {
                        id: generateTileId(),
                        type: 'kpis',
                        x: 0,
                        y: 0,
                        width,
                        height: kpiHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.kpis)
                    },
                    {
                        id: generateTileId(),
                        type: 'bigStat',
                        x: 0,
                        y: yAfterKpi,
                        width: leftWidth,
                        height: bigStatHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.bigStat)
                    },
                    {
                        id: generateTileId(),
                        type: 'highlights',
                        x: 0,
                        y: yAfterBigStat,
                        width: leftWidth,
                        height: highlightHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.highlights)
                    },
                    {
                        id: generateTileId(),
                        type: 'blogs',
                        x: leftWidth + gap,
                        y: yAfterKpi,
                        width: rightWidth,
                        height: blogsHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.blogs)
                    },
                    {
                        id: generateTileId(),
                        type: 'graph',
                        x: leftWidth + gap,
                        y: yAfterBlogs,
                        width: rightWidth,
                        height: graphHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.graph)
                    },
                    {
                        id: generateTileId(),
                        type: 'demographics',
                        x: leftWidth + gap,
                        y: yAfterGraph,
                        width: rightWidth,
                        height: demoHeight,
                        data: cloneValue(DEFAULT_TILE_DATA.demographics)
                    }
                ];
            }

            function normalizeTileData(tile) {
                if (!tile.data || typeof tile.data !== 'object') {
                    tile.data = {};
                }
                const defaults = DEFAULT_TILE_DATA[tile.type];
                if (defaults) {
                    applyDefaults(tile.data, cloneValue(defaults));
                }

                if (tile.type === 'kpis') {
                    if (!Array.isArray(tile.data.kpis)) {
                        tile.data.kpis = cloneValue(DEFAULT_TILE_DATA.kpis.kpis);
                    }
                    normalizeKpiList(tile.data.kpis);
                }
                if (tile.type === 'highlights') {
                    if (!Array.isArray(tile.data.items)) {
                        tile.data.items = cloneValue(DEFAULT_TILE_DATA.highlights.items);
                    }
                }
                if (tile.type === 'blogs') {
                    if (!Array.isArray(tile.data.items)) {
                        tile.data.items = cloneValue(DEFAULT_TILE_DATA.blogs.items);
                    }
                }
                if (tile.type === 'demographics') {
                    if (!Array.isArray(tile.data.items)) {
                        tile.data.items = cloneValue(DEFAULT_TILE_DATA.demographics.items);
                    }
                }
                if (tile.type === 'graph') {
                    if (!Array.isArray(tile.data.series)) {
                        tile.data.series = cloneValue(DEFAULT_TILE_DATA.graph.series);
                    }
                }
            }

            function normalizeTilesState() {
                if (!Array.isArray(state.tiles) || state.tiles.length === 0) {
                    state.tiles = buildDefaultTiles();
                }

                state.tiles = state.tiles.filter(tile => tile && TILE_TEMPLATE_IDS[tile.type]);

                state.tiles.forEach(tile => {
                    if (!tile.id) tile.id = generateTileId();
                    tile.x = Math.max(0, Number(tile.x ?? 0));
                    tile.y = Math.max(0, Number(tile.y ?? 0));
                    tile.width = Math.max(180, Number(tile.width ?? 320));
                    tile.height = Math.max(120, Number(tile.height ?? 180));
                    normalizeTileData(tile);
                });

                if (!selectedTileId || !getTileById(selectedTileId)) {
                    selectedTileId = state.tiles[0]?.id || null;
                }
            }

            function getTileById(id) {
                return state.tiles.find(tile => tile.id === id);
            }

            function getTilesByType(type) {
                return state.tiles.filter(tile => tile.type === type);
            }

            function getSelectedTile() {
                return getTileById(selectedTileId) || state.tiles[0] || null;
            }

            function getActiveTile(type) {
                const selected = getSelectedTile();
                if (selected && selected.type === type) return selected;
                return state.tiles.find(tile => tile.type === type) || null;
            }

            function applyTilePosition(tile, node) {
                node.style.left = `${tile.x}px`;
                node.style.top = `${tile.y}px`;
                node.style.width = `${tile.width}px`;
                node.style.height = `${tile.height}px`;
            }

            function renderTileCanvas() {
                const canvas = document.getElementById('tile-canvas');
                if (!canvas) return;
                canvas.innerHTML = '';
                normalizeTilesState();

                state.tiles.forEach(tile => {
                    const templateId = TILE_TEMPLATE_IDS[tile.type];
                    const template = document.getElementById(templateId);
                    if (!template) return;
                    const node = template.content.firstElementChild.cloneNode(true);
                    node.dataset.tileId = tile.id;
                    node.dataset.tileType = tile.type;
                    applyTilePosition(tile, node);
                    canvas.appendChild(node);
                });
            }

            function setLayoutEditing(enabled) {
                layoutEditing = Boolean(enabled);
                document.body.classList.toggle('preview-editing', layoutEditing);
                const toggle = document.getElementById('preview-edit-toggle');
                if (toggle) {
                    toggle.textContent = layoutEditing ? 'Editing On' : 'Update Preview';
                }
            }

            function getCanvasSize() {
                const preview = document.getElementById('dashboard-preview');
                if (!preview) return { width: 0, height: 0 };
                return { width: preview.clientWidth, height: preview.clientHeight };
            }

            function getSnapTargets(excludeId) {
                return state.tiles
                    .filter(tile => tile.id !== excludeId)
                    .map(tile => ({
                        left: tile.x,
                        right: tile.x + tile.width,
                        top: tile.y,
                        bottom: tile.y + tile.height
                    }));
            }

            function snapPosition(value, size, axis, targets, canvasSize) {
                const threshold = 8;
                let snapped = value;
                const edges = [];
                targets.forEach(target => {
                    edges.push(axis === 'x' ? target.left : target.top);
                    edges.push(axis === 'x' ? target.right : target.bottom);
                });
                edges.push(0);
                edges.push(canvasSize);

                let minDiff = threshold;
                edges.forEach(edge => {
                    const startDiff = Math.abs(value - edge);
                    if (startDiff < minDiff) {
                        minDiff = startDiff;
                        snapped = edge;
                    }
                    const endDiff = Math.abs(value + size - edge);
                    if (endDiff < minDiff) {
                        minDiff = endDiff;
                        snapped = edge - size;
                    }
                });

                return snapToGrid(snapped);
            }

            function snapSize(value, start, axis, targets, canvasSize) {
                const threshold = 8;
                let snapped = value;
                const edges = [];
                targets.forEach(target => {
                    edges.push(axis === 'x' ? target.left : target.top);
                    edges.push(axis === 'x' ? target.right : target.bottom);
                });
                edges.push(canvasSize);

                let minDiff = threshold;
                edges.forEach(edge => {
                    const diff = Math.abs(start + value - edge);
                    if (diff < minDiff) {
                        minDiff = diff;
                        snapped = edge - start;
                    }
                });

                return snapToGrid(snapped);
            }

            function registerDragAndDrop() {
                const handles = document.querySelectorAll('.drag-handle');
                handles.forEach(handle => {
                    handle.addEventListener('pointerdown', (event) => {
                        if (!layoutEditing) return;
                        const card = handle.closest('.layout-card');
                        if (!card) return;
                        const tileId = card.dataset.tileId;
                        const tile = getTileById(tileId);
                        if (!tile) return;
                        const previousUserSelect = document.body.style.userSelect;
                        document.body.style.userSelect = 'none';
                        const pointerId = event.pointerId;
                        try {
                            handle.setPointerCapture(pointerId);
                        } catch (err) {
                            // ignore
                        }
                        const startX = event.clientX;
                        const startY = event.clientY;
                        const startLeft = tile.x;
                        const startTop = tile.y;
                        const targets = getSnapTargets(tileId);
                        const canvasSize = getCanvasSize();

                        const onMove = (moveEvent) => {
                            const dx = moveEvent.clientX - startX;
                            const dy = moveEvent.clientY - startY;
                            let nextLeft = startLeft + dx;
                            let nextTop = startTop + dy;
                            nextLeft = snapPosition(nextLeft, tile.width, 'x', targets, canvasSize.width);
                            nextTop = snapPosition(nextTop, tile.height, 'y', targets, canvasSize.height);
                            tile.x = Math.max(0, Math.min(nextLeft, canvasSize.width - tile.width));
                            tile.y = Math.max(0, Math.min(nextTop, canvasSize.height - tile.height));
                            applyTilePosition(tile, card);
                        };

                        const onUp = () => {
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            document.body.style.userSelect = previousUserSelect;
                            try {
                                handle.releasePointerCapture(pointerId);
                            } catch (err) {
                                // ignore
                            }
                            queueSaveDraft();
                        };

                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                        event.preventDefault();
                    });
                });
            }

            function registerResizeHandles() {
                const handles = document.querySelectorAll('.resize-handle');
                handles.forEach((handle) => {
                    handle.addEventListener('pointerdown', (event) => {
                        if (!layoutEditing) return;
                        const card = handle.closest('.layout-card');
                        if (!card) return;
                        const tileId = card.dataset.tileId;
                        const tile = getTileById(tileId);
                        if (!tile) return;
                        const previousUserSelect = document.body.style.userSelect;
                        document.body.style.userSelect = 'none';
                        const pointerId = event.pointerId;
                        try {
                            handle.setPointerCapture(pointerId);
                        } catch (err) {
                            // ignore
                        }
                        const startX = event.clientX;
                        const startY = event.clientY;
                        const startWidth = tile.width;
                        const startHeight = tile.height;
                        const targets = getSnapTargets(tileId);
                        const canvasSize = getCanvasSize();
                        const minWidth = 180;
                        const minHeight = 120;

                        const onMove = (moveEvent) => {
                            const dx = moveEvent.clientX - startX;
                            const dy = moveEvent.clientY - startY;
                            let nextWidth = Math.max(minWidth, startWidth + dx);
                            let nextHeight = Math.max(minHeight, startHeight + dy);
                            nextWidth = snapSize(nextWidth, tile.x, 'x', targets, canvasSize.width);
                            nextHeight = snapSize(nextHeight, tile.y, 'y', targets, canvasSize.height);
                            tile.width = Math.max(minWidth, nextWidth);
                            tile.height = Math.max(minHeight, nextHeight);
                            applyTilePosition(tile, card);
                        };

                        const onUp = () => {
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            document.body.style.userSelect = previousUserSelect;
                            try {
                                handle.releasePointerCapture(pointerId);
                            } catch (err) {
                                // ignore
                            }
                            queueSaveDraft();
                        };

                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                        event.preventDefault();
                    });
                });
            }

            function registerCanvasResize() {
                const handle = document.querySelector('.preview-resize-handle');
                const preview = document.getElementById('dashboard-preview');
                if (!handle || !preview) return;

                handle.addEventListener('pointerdown', (event) => {
                    if (!layoutEditing) return;
                    const previousUserSelect = document.body.style.userSelect;
                    document.body.style.userSelect = 'none';
                    const pointerId = event.pointerId;
                    try {
                        handle.setPointerCapture(pointerId);
                    } catch (err) {
                        // Ignore if pointer capture is not supported.
                    }
                    const startRect = preview.getBoundingClientRect();
                    const startX = event.clientX;
                    const startY = event.clientY;
                    const minWidth = 640;
                    const minHeight = 360;

                    const onMove = (moveEvent) => {
                        const dx = moveEvent.clientX - startX;
                        const dy = moveEvent.clientY - startY;
                        const nextWidth = Math.max(minWidth, startRect.width + dx);
                        const nextHeight = Math.max(minHeight, startRect.height + dy);
                        const snappedWidth = snapToGrid(nextWidth);
                        const snappedHeight = snapToGrid(nextHeight);
                        preview.style.setProperty('--preview-width', `${Math.round(snappedWidth)}px`);
                        preview.style.height = `${Math.round(snappedHeight)}px`;
                    };

                    const onUp = () => {
                        document.removeEventListener('pointermove', onMove);
                        document.removeEventListener('pointerup', onUp);
                        document.body.style.userSelect = previousUserSelect;
                        try {
                            handle.releasePointerCapture(pointerId);
                        } catch (err) {
                            // Ignore if pointer capture is not supported.
                        }
                        const finalRect = preview.getBoundingClientRect();
                        setByPath(state.theme, 'preview.width', Math.round(finalRect.width));
                        setByPath(state.theme, 'preview.height', Math.round(finalRect.height));
                        applyThemeToPreview(state);
                        queueSaveDraft();
                    };

                    document.addEventListener('pointermove', onMove);
                    document.addEventListener('pointerup', onUp);
                    event.preventDefault();
                });
            }

            function registerCanvasPanning() {
                const surface = document.querySelector('.canvas-surface');
                if (!surface) return;
                let isPanning = false;
                let startX = 0;
                let startY = 0;
                let startScrollLeft = 0;
                let startScrollTop = 0;
                let activePointerId = null;

                const shouldIgnoreTarget = (target) => {
                    if (!target) return false;
                    return Boolean(
                        target.closest('.layout-card') ||
                        target.closest('.preview-resize-handle') ||
                        target.closest('.resize-handle') ||
                        target.closest('input, textarea, select, button, a')
                    );
                };

                const onPointerDown = (event) => {
                    if (event.button !== 0) return;
                    if (shouldIgnoreTarget(event.target)) return;
                    isPanning = true;
                    activePointerId = event.pointerId;
                    startX = event.clientX;
                    startY = event.clientY;
                    startScrollLeft = surface.scrollLeft;
                    startScrollTop = surface.scrollTop;
                    surface.classList.add('is-panning');
                    try {
                        surface.setPointerCapture(activePointerId);
                    } catch (err) {
                        // ignore
                    }
                    event.preventDefault();
                };

                const onPointerMove = (event) => {
                    if (!isPanning) return;
                    const dx = event.clientX - startX;
                    const dy = event.clientY - startY;
                    surface.scrollLeft = startScrollLeft - dx;
                    surface.scrollTop = startScrollTop - dy;
                };

                const stopPanning = () => {
                    if (!isPanning) return;
                    isPanning = false;
                    surface.classList.remove('is-panning');
                    if (activePointerId !== null) {
                        try {
                            surface.releasePointerCapture(activePointerId);
                        } catch (err) {
                            // ignore
                        }
                    }
                    activePointerId = null;
                };

                surface.addEventListener('pointerdown', onPointerDown);
                surface.addEventListener('pointermove', onPointerMove);
                surface.addEventListener('pointerup', stopPanning);
                surface.addEventListener('pointerleave', stopPanning);
            }

            function registerInlineEditors() {
                const canvas = document.getElementById('tile-canvas');
                if (!canvas) return;
                canvas.addEventListener('keydown', (event) => {
                    const target = event.target;
                    if (event.key === 'Enter' && target && target.isContentEditable) {
                        event.preventDefault();
                        target.blur();
                    }
                });
                canvas.addEventListener('blur', (event) => {
                    const target = event.target;
                    if (!target || !target.isContentEditable) return;
                    const field = target.getAttribute('data-edit');
                    if (!field) return;
                    const card = target.closest('.layout-card');
                    if (!card) return;
                    const tileId = card.dataset.tileId;
                    const value = target.innerText.trim();
                    if (field === 'bigStat.value') {
                        updateBigStat(value, tileId);
                    } else if (field === 'bigStat.label') {
                        updateBigStatLabel(value, tileId);
                    } else if (field === 'highlights.title') {
                        updateHighlightTitle(value, tileId);
                    } else if (field === 'blogs.title') {
                        updateBlogsTitle(value, tileId);
                    } else if (field === 'blogs.subtitle') {
                        updateBlogsSubtitle(value, tileId);
                    } else if (field === 'graph.title') {
                        updateGraphTitle(value, tileId);
                    } else if (field === 'graph.subtitle') {
                        updateGraphSubtitle(value, tileId);
                    } else if (field === 'demographics.title') {
                        updateDemographicsTitle(value, tileId);
                    }
                }, true);
            }

            function registerTileSelection() {
                const preview = document.getElementById('dashboard-preview');
                if (!preview) return;
                preview.addEventListener('click', (event) => {
                    const actionButton = event.target.closest('[data-tile-action]');
                    if (actionButton) {
                        event.stopPropagation();
                        const action = actionButton.getAttribute('data-tile-action');
                        const card = actionButton.closest('.layout-card');
                        const tileId = card?.dataset.tileId;
                        if (!tileId) return;
                        if (action === 'edit') {
                            setSelectedTile(tileId);
                        } else if (action === 'duplicate') {
                            duplicateTile(tileId);
                        } else if (action === 'remove') {
                            removeTile(tileId);
                        }
                        return;
                    }
                    const card = event.target.closest('.layout-card');
                    if (card && layoutEditing) {
                        if (event.target.closest('button, input, textarea, select')) return;
                        setSelectedTile(card.dataset.tileId);
                    }
                });
            }

            let activeThemeGroup = THEME_CONTROL_GROUPS[0]?.title || 'Global';

            const TILE_TYPES = [
                { id: 'kpis', label: 'KPI Row' },
                { id: 'bigStat', label: 'Hero Stat' },
                { id: 'highlights', label: 'Highlights' },
                { id: 'blogs', label: 'Top Blogs' },
                { id: 'graph', label: 'Graph' },
                { id: 'demographics', label: 'Sources' }
            ];

            function updateTileSelectionDisplay() {
                const selected = getSelectedTile();
                if (!selected) return;
                selectedTileId = selected.id;
                document.querySelectorAll('.layout-card').forEach(card => {
                    card.classList.toggle('tile-selected', card.dataset.tileId === selected.id);
                });
                document.querySelectorAll('[data-tile-editor]').forEach(section => {
                    section.style.display = section.getAttribute('data-tile-editor') === selected.type ? '' : 'none';
                });
                document.querySelectorAll('[data-tile-instance]').forEach(row => {
                    row.classList.toggle('active', row.getAttribute('data-tile-instance') === selected.id);
                });
                const label = document.getElementById('selected-tile-label');
                if (label) {
                    const match = TILE_TYPES.find(tile => tile.id === selected.type);
                    label.textContent = match ? match.label : selected.type;
                }
            }

            function setSelectedTile(nextId) {
                if (!nextId) return;
                selectedTileId = nextId;
                updateTileSelectionDisplay();
            }

            function renderTileLibrary() {
                const container = document.getElementById('tile-type-list');
                if (!container) return;
                container.innerHTML = '';

                const addTitle = document.createElement('div');
                addTitle.className = 'tile-library-title';
                addTitle.textContent = 'Add Tiles';
                container.appendChild(addTitle);

                TILE_TYPES.forEach(tile => {
                    const row = document.createElement('div');
                    row.className = 'tile-library-item';
                    const label = document.createElement('div');
                    label.className = 'tile-library-label';
                    label.textContent = tile.label;

                    const action = document.createElement('button');
                    action.type = 'button';
                    action.className = 'tile-library-action';
                    action.textContent = 'Add';
                    action.addEventListener('click', (event) => {
                        event.stopPropagation();
                        addTile(tile.id);
                    });

                    row.appendChild(label);
                    row.appendChild(action);
                    container.appendChild(row);
                });

                const divider = document.createElement('div');
                divider.className = 'inspector-divider';
                container.appendChild(divider);

                const listTitle = document.createElement('div');
                listTitle.className = 'tile-library-title';
                listTitle.textContent = 'Tiles';
                container.appendChild(listTitle);

                const typeCounts = {};
                state.tiles.forEach(tile => {
                    typeCounts[tile.type] = (typeCounts[tile.type] || 0) + 1;
                    const row = document.createElement('div');
                    row.className = 'tile-library-item';
                    row.setAttribute('data-tile-instance', tile.id);
                    row.addEventListener('click', () => setSelectedTile(tile.id));

                    const label = document.createElement('div');
                    label.className = 'tile-library-label';
                    const typeMeta = TILE_TYPES.find(t => t.id === tile.type);
                    const name = typeMeta ? typeMeta.label : tile.type;
                    label.textContent = `${name} ${typeCounts[tile.type]}`;

                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'tile-library-action active';
                    removeBtn.textContent = 'Remove';
                    removeBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        removeTile(tile.id);
                    });

                    row.appendChild(label);
                    row.appendChild(removeBtn);
                    container.appendChild(row);
                });

                updateTileSelectionDisplay();
            }

            function renderBoxControls() {
                const quickContainer = document.getElementById('box-quick-controls');
                const themeContainer = document.getElementById('box-theme-controls');
                const previewToggle = document.getElementById('preview-edit-toggle');

                if (previewToggle) {
                    previewToggle.textContent = layoutEditing ? 'Editing On' : 'Update Preview';
                    previewToggle.onclick = () => setLayoutEditing(!layoutEditing);
                }

                if (quickContainer) {
                    quickContainer.innerHTML = '';

                    const fontRow = document.createElement('div');
                    fontRow.className = 'control-row';
                    const fontLabel = document.createElement('span');
                    fontLabel.textContent = 'Font';
                    const fontSelect = document.createElement('select');
                    FONT_CHOICES.forEach(choice => {
                        const option = document.createElement('option');
                        option.value = choice.value;
                        option.textContent = choice.label;
                        fontSelect.appendChild(option);
                    });
                    fontSelect.value = state.theme?.typography?.fontFamily || FONT_CHOICES[0].value;
                    fontSelect.addEventListener('change', () => {
                        setByPath(state.theme, 'typography.fontFamily', fontSelect.value);
                        applyThemeToPreview(state);
                        queueSaveDraft();
                    });
                    fontRow.appendChild(fontLabel);
                    fontRow.appendChild(fontSelect);
                    quickContainer.appendChild(fontRow);

                    [
                        { label: 'Preview Width', path: 'preview.width', min: 800, max: 1400, step: 10 },
                        { label: 'Preview Height', path: 'preview.height', min: 0, max: 1200, step: 10 },
                        { label: 'Preview Padding', path: 'preview.padding', min: 0, max: 16, step: 1 },
                        { label: 'Layout Gap', path: 'layout.gap', min: 0, max: 16, step: 1 },
                        { label: 'KPI Gap', path: 'layout.kpiGap', min: 0, max: 16, step: 1 }
                    ].forEach(control => {
                        const row = document.createElement('div');
                        row.className = 'control-row';
                        const label = document.createElement('span');
                        label.textContent = control.label;
                        const input = document.createElement('input');
                        input.type = 'range';
                        input.min = control.min;
                        input.max = control.max;
                        input.step = control.step;
                        const current = getByPath(state.theme, control.path);
                        input.value = current ?? control.min;
                        input.addEventListener('input', () => {
                            setByPath(state.theme, control.path, Number(input.value));
                            applyThemeToPreview(state);
                            queueSaveDraft();
                        });
                        row.appendChild(label);
                        row.appendChild(input);
                        quickContainer.appendChild(row);
                    });

                    const colorWrap = document.createElement('div');
                    colorWrap.className = 'space-y-2';
                    quickContainer.appendChild(colorWrap);
                    renderPreviewColorControls(colorWrap, state, () => {
                        applyThemeToPreview(state);
                        queueSaveDraft();
                    });
                }

                if (themeContainer) {
                    themeContainer.innerHTML = '';
                    const groupRow = document.createElement('div');
                    groupRow.className = 'control-row';
                    const groupLabel = document.createElement('span');
                    groupLabel.textContent = 'Theme Group';
                    const groupSelect = document.createElement('select');
                    THEME_CONTROL_GROUPS.forEach(group => {
                        const option = document.createElement('option');
                        option.value = group.title;
                        option.textContent = group.title;
                        groupSelect.appendChild(option);
                    });
                    groupSelect.value = activeThemeGroup;
                    groupSelect.addEventListener('change', () => {
                        activeThemeGroup = groupSelect.value;
                        renderBoxControls();
                    });
                    groupRow.appendChild(groupLabel);
                    groupRow.appendChild(groupSelect);
                    themeContainer.appendChild(groupRow);

                    const controlsBody = document.createElement('div');
                    controlsBody.className = 'space-y-2';
                    themeContainer.appendChild(controlsBody);
                    renderThemeControls(controlsBody, state, () => {
                        applyThemeToPreview(state);
                        queueSaveDraft();
                    }, activeThemeGroup);

                    const resetBtn = document.createElement('button');
                    resetBtn.type = 'button';
                    resetBtn.className = 'inspector-button';
                    resetBtn.textContent = 'Reset Theme';
                    resetBtn.addEventListener('click', () => {
                        state.theme = cloneValue(YEARLY_THEME_DEFAULTS);
                        normalizeThemeState(state, YEARLY_THEME_DEFAULTS);
                        applyThemeToPreview(state);
                        renderBoxControls();
                        queueSaveDraft();
                    });
                    themeContainer.appendChild(resetBtn);
                }
            }

            function renderTileStyleControls() {
                document.querySelectorAll('[data-style-group]').forEach((el) => {
                    const group = el.getAttribute('data-style-group');
                    if (!group) return;
                    renderThemeControls(el, state, () => {
                        applyThemeToPreview(state);
                        renderAll();
                        queueSaveDraft();
                    }, group);
                });
            }

            function renderInspectorControls() {
                const inspector = document.querySelector('.studio-inspector');
                if (isExport) {
                    if (inspector) inspector.style.display = 'none';
                    return;
                }
                if (inspector) inspector.style.display = 'flex';
                renderTileLibrary();
                renderBoxControls();
                renderTileStyleControls();
                updateTileSelectionDisplay();
            }

            function renderBigStat() {
                const tiles = getTilesByType('bigStat');
                tiles.forEach(tile => {
                    const node = document.querySelector(`.layout-card[data-tile-id="${tile.id}"]`);
                    if (!node) return;
                    const valueEl = node.querySelector('[data-edit="bigStat.value"]');
                    const labelEl = node.querySelector('[data-edit="bigStat.label"]');
                    if (valueEl) valueEl.innerText = tile.data.value ?? '';
                    if (labelEl) labelEl.innerText = tile.data.label ?? '';
                });

                const active = getActiveTile('bigStat');
                if (!active) return;
                const input = document.getElementById('big-stat-input');
                const labelInput = document.getElementById('big-stat-label-input');
                if (input) input.value = active.data.value ?? '';
                if (labelInput) labelInput.value = active.data.label ?? '';
            }

            function renderKPIs() {
                const activeTile = getActiveTile('kpis');
                const inputContainer = document.getElementById('kpi-inputs');
                if (inputContainer) inputContainer.innerHTML = '';
                if (activeTile) {
                    normalizeKpiList(activeTile.data.kpis);
                    activeTile.data.kpis.forEach((kpi, i) => {
                        const div = document.createElement('div');
                        div.className = "section-group relative";
                        div.innerHTML = `
                            <div class="flex justify-between items-center mb-1">
                                <label class="!mt-0 font-bold text-xs uppercase text-cyan-500">KPI ${i + 1}</label>
                                <span onclick="removeItem('kpi', ${i}, '${activeTile.id}')" class="remove-btn">Remove</span>
                            </div>
                            <label class="!mt-0">Title</label>
                            <input type="text" value="${kpi.title}" oninput="updateState('kpi', ${i}, 'title', this.value, '${activeTile.id}')" class="mb-2" placeholder="Title">
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="!mt-0">Prev</label>
                                    <input type="text" value="${kpi.prev}" oninput="updateState('kpi', ${i}, 'prev', this.value, '${activeTile.id}')" placeholder="Prev">
                                </div>
                                <div>
                                    <label class="!mt-0">Curr</label>
                                    <input type="text" value="${kpi.curr}" oninput="updateState('kpi', ${i}, 'curr', this.value, '${activeTile.id}')" placeholder="Curr">
                                </div>
                            </div>
                            <label>Delta Override (optional)</label>
                            <input type="text" value="${kpi.deltaOverride || ''}" oninput="updateKpiDeltaOverride('${activeTile.id}', ${i}, this.value)" placeholder="+10.5%">
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="!mt-0">Card From</label>
                                    <input type="color" value="${kpi.theme?.from || getDefaultKpiTheme(i).from}" oninput="updateKpiTheme('${activeTile.id}', ${i}, 'from', this.value)">
                                </div>
                                <div>
                                    <label class="!mt-0">Card To</label>
                                    <input type="color" value="${kpi.theme?.to || getDefaultKpiTheme(i).to}" oninput="updateKpiTheme('${activeTile.id}', ${i}, 'to', this.value)">
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="!mt-0">Title Color</label>
                                    <input type="color" value="${kpi.theme?.titleColor || getDefaultKpiTheme(i).titleColor}" oninput="updateKpiTheme('${activeTile.id}', ${i}, 'titleColor', this.value)">
                                </div>
                                <div>
                                    <label class="!mt-0">Value Color</label>
                                    <input type="color" value="${kpi.theme?.valueColor || getDefaultKpiTheme(i).valueColor}" oninput="updateKpiTheme('${activeTile.id}', ${i}, 'valueColor', this.value)">
                                </div>
                            </div>
                        `;
                        if (inputContainer) inputContainer.appendChild(div);
                    });
                }

                const theme = state.theme || DEFAULT_THEME;
                getTilesByType('kpis').forEach(tile => {
                    const previewContainer = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] .kpi-preview-container`);
                    if (!previewContainer) return;
                    normalizeKpiList(tile.data.kpis);
                    previewContainer.innerHTML = '';
                    const colCount = Math.min(tile.data.kpis.length, 6) || 1;
                    previewContainer.style.gridTemplateColumns = `repeat(${colCount}, 1fr)`;

                    tile.data.kpis.forEach((kpi, i) => {
                        const prev = parseNumberLike(kpi.prev);
                        const curr = parseNumberLike(kpi.curr);
                        const deltaOverride = (kpi.deltaOverride || '').trim();

                        let pctText = "N/A";
                        let pctStyle = `background-color: ${applyAlpha(theme.kpi.deltaNeutralBg, theme.kpi.deltaNeutralOpacity)}; color: ${theme.kpi.deltaNeutralText};`;

                        if (deltaOverride) {
                            pctText = deltaOverride;
                            const sign = detectDeltaSign(deltaOverride);
                            if (sign > 0) {
                                pctStyle = `background-color: ${applyAlpha(theme.kpi.deltaPositiveBg, theme.kpi.deltaPositiveOpacity)}; color: ${theme.kpi.deltaPositiveText};`;
                            } else if (sign < 0) {
                                pctStyle = `background-color: ${applyAlpha(theme.kpi.deltaNegativeBg, theme.kpi.deltaNegativeOpacity)}; color: ${theme.kpi.deltaNegativeText};`;
                            }
                        } else if (prev.isNumeric && curr.isNumeric && prev.numeric !== 0) {
                            const change = ((curr.numeric - prev.numeric) / prev.numeric) * 100;
                            pctText = `${change > 0 ? "+" : ""}${change.toFixed(1)}%`;
                            pctStyle = change >= 0
                                ? `background-color: ${applyAlpha(theme.kpi.deltaPositiveBg, theme.kpi.deltaPositiveOpacity)}; color: ${theme.kpi.deltaPositiveText};`
                                : `background-color: ${applyAlpha(theme.kpi.deltaNegativeBg, theme.kpi.deltaNegativeOpacity)}; color: ${theme.kpi.deltaNegativeText};`;
                        }

                        const card = document.createElement('div');
                        card.className = "kpi-card";
                        const cardTheme = kpi.theme || getDefaultKpiTheme(i);
                        card.style.cssText = `background: linear-gradient(to bottom, ${applyAlpha(cardTheme.from, theme.effects?.kpiOpacity ?? 1)}, ${applyAlpha(cardTheme.to, theme.effects?.kpiOpacity ?? 1)}); padding: 16px; text-align: center; display: flex; flex-direction: column; justify-content: center; min-height: 80px;`;
                        card.innerHTML = `
                            <div class="kpi-title editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('kpi', ${i}, 'title', this.innerText.trim(), '${tile.id}')"
                                style="font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; opacity: 0.7; margin-bottom: 4px; color: ${cardTheme.titleColor || theme.kpi?.titleColor || '#111827'};">${kpi.title}</div>
                            <div class="kpi-value editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateKpiValue('${tile.id}', ${i}, this.innerText.trim())"
                                style="font-size: 28px; font-weight: 800; line-height: 1; color: ${cardTheme.valueColor || theme.kpi?.valueColor || '#111827'};">${formatNumberLike(kpi.curr)}</div>
                            <div style="margin-top: 6px;">
                                <span class="kpi-delta editable" contenteditable="true"
                                    onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                    onblur="updateKpiDeltaOverride('${tile.id}', ${i}, this.innerText.trim())"
                                    style="font-size: 11px; font-weight: 700; padding: 2px 8px; border-radius: 4px; white-space: nowrap; ${pctStyle}">${pctText}</span>
                            </div>
                        `;
                        previewContainer.appendChild(card);
                    });
                });
                applyThemeToPreview(state);
            }

            function renderHighlights() {
                const activeTile = getActiveTile('highlights');
                const inputContainer = document.getElementById('highlight-inputs');
                if (inputContainer) {
                    inputContainer.innerHTML = '';
                    if (activeTile) {
                        activeTile.data.items.forEach((text, i) => {
                            const div = document.createElement('div');
                            div.className = "section-group";
                            div.innerHTML = `
                                <div class="flex justify-between items-center mb-1">
                                    <label class="!mt-0">Point ${i + 1}</label>
                                    <span onclick="removeItem('highlight', ${i}, '${activeTile.id}')" class="remove-btn">Remove</span>
                                </div>
                                <textarea rows="2" oninput="updateState('highlight', ${i}, null, this.value, '${activeTile.id}')">${text}</textarea>
                            `;
                            inputContainer.appendChild(div);
                        });
                    }
                }

                getTilesByType('highlights').forEach(tile => {
                    const previewList = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] .highlight-preview-list`);
                    const titleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="highlights.title"]`);
                    if (titleDisplay) titleDisplay.innerText = tile.data.title ?? '';
                    if (!previewList) return;
                    previewList.innerHTML = '';
                    tile.data.items.forEach((text, i) => {
                        const row = document.createElement('div');
                        row.className = "flex items-start gap-3";
                        row.innerHTML = `
                            <span class="text-xl leading-none highlight-bullet" style="margin-top: -2px;">&bull;</span>
                            <span class="leading-relaxed highlight-text editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('highlight', ${i}, null, this.innerText.trim(), '${tile.id}')">${text}</span>
                        `;
                        previewList.appendChild(row);
                    });
                });

                const titleInput = document.getElementById('highlight-title-input');
                if (titleInput && activeTile) {
                    titleInput.value = activeTile.data.title ?? '';
                }
            }

            function renderBlogs() {
                const activeTile = getActiveTile('blogs');
                const inputContainer = document.getElementById('blog-inputs');
                if (inputContainer) {
                    inputContainer.innerHTML = '';
                    if (activeTile) {
                        activeTile.data.items.forEach((blog, i) => {
                            const div = document.createElement('div');
                            div.className = "section-group";
                            div.innerHTML = `
                                <div class="flex justify-between items-center mb-1">
                                    <label class="!mt-0 font-bold text-xs uppercase">Blog ${i + 1}</label>
                                    <span onclick="removeItem('blog', ${i}, '${activeTile.id}')" class="remove-btn">Remove</span>
                                </div>
                                <input type="text" value="${blog.title}" oninput="updateState('blog', ${i}, 'title', this.value, '${activeTile.id}')" class="mb-2" placeholder="Title">
                                <input type="text" value="${blog.views}" oninput="updateState('blog', ${i}, 'views', this.value, '${activeTile.id}')" placeholder="Views">
                            `;
                            inputContainer.appendChild(div);
                        });
                    }
                }

                getTilesByType('blogs').forEach(tile => {
                    const previewList = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] .blog-preview-list`);
                    const titleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="blogs.title"]`);
                    const subtitleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="blogs.subtitle"]`);
                    if (titleDisplay) titleDisplay.innerText = tile.data.title ?? '';
                    if (subtitleDisplay) subtitleDisplay.innerText = tile.data.subtitle ?? '';
                    if (!previewList) return;
                    previewList.innerHTML = '';
                    tile.data.items.forEach((blog, i) => {
                        const div = document.createElement('div');
                        div.className = `blog-row ${i % 2 === 0 ? 'even' : 'odd'}`;
                        div.style.cssText = "display: flex; justify-content: space-between; align-items: center; padding: 10px 12px;";
                        div.innerHTML = `
                            <span class="blog-title editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('blog', ${i}, 'title', this.innerText.trim(), '${tile.id}')"
                                style="font-weight: 600; font-size: 13px; line-height: 1.6;">${blog.title}</span>
                            <span class="blog-views editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('blog', ${i}, 'views', this.innerText.trim(), '${tile.id}')"
                                style="font-weight: 700; padding: 4px 8px; border-radius: 4px; font-size: 11px; white-space: nowrap; margin-left: 12px; flex-shrink: 0;">${blog.views}</span>
                        `;
                        previewList.appendChild(div);
                    });
                });

                const titleInput = document.getElementById('blogs-title-input');
                const subtitleInput = document.getElementById('blogs-subtitle-input');
                if (titleInput && activeTile) titleInput.value = activeTile.data.title ?? '';
                if (subtitleInput && activeTile) subtitleInput.value = activeTile.data.subtitle ?? '';
            }

            function renderGraph() {
                const activeTile = getActiveTile('graph');
                if (activeTile) {
                    const titleInput = document.getElementById('graph-title-input');
                    const subtitleInput = document.getElementById('graph-subtitle-input');
                    const typeInput = document.getElementById('graph-type-input');
                    if (titleInput) titleInput.value = activeTile.data.title || '';
                    if (subtitleInput) subtitleInput.value = activeTile.data.subtitle || '';
                    if (typeInput) typeInput.value = activeTile.data.type || 'line';

                    const inputContainer = document.getElementById('graph-inputs');
                    if (inputContainer) {
                        inputContainer.innerHTML = '';
                        activeTile.data.series.forEach((point, i) => {
                            const div = document.createElement('div');
                            div.className = 'section-group grid grid-cols-2 gap-2 items-end';
                            div.innerHTML = `
                                <div class="col-span-2 flex justify-between">
                                    <label class="!mt-0 font-bold text-xs">Point ${i + 1}</label>
                                    <span onclick="removeItem('graphPoint', ${i}, '${activeTile.id}')" class="remove-btn">Remove</span>
                                </div>
                                <input type="text" value="${point.label}" oninput="updateState('graphPoint', ${i}, 'label', this.value, '${activeTile.id}')" placeholder="Label">
                                <input type="text" value="${point.value}" oninput="updateState('graphPoint', ${i}, 'value', this.value, '${activeTile.id}')" placeholder="Value">
                            `;
                            inputContainer.appendChild(div);
                        });
                    }
                }

                getTilesByType('graph').forEach(tile => {
                    const svg = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] .graph-svg`);
                    const labels = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] .graph-labels`);
                    const titleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="graph.title"]`);
                    const subtitleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="graph.subtitle"]`);
                    if (titleDisplay) titleDisplay.innerText = tile.data.title || '';
                    if (subtitleDisplay) subtitleDisplay.innerText = tile.data.subtitle || '';
                    if (!svg) return;
                    const points = Array.isArray(tile.data.series) ? tile.data.series : [];
                    if (points.length === 0) {
                        svg.innerHTML = '';
                        if (labels) labels.innerHTML = '';
                        return;
                    }

                    const width = 300;
                    const height = 140;
                    const values = points.map(point => {
                        const parsed = parseNumberLike(point.value);
                        return parsed.isNumeric ? parsed.numeric : 0;
                    });
                    const maxValue = Math.max(...values, 1);
                    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

                    let svgMarkup = '';
                    for (let i = 1; i < 4; i += 1) {
                        const y = (height * i) / 4;
                        svgMarkup += `<line x1="0" y1="${y}" x2="${width}" y2="${y}" stroke="var(--graph-grid)" stroke-width="1" />`;
                    }

                    if (tile.data.type === 'bar') {
                        const slot = width / points.length;
                        const barWidth = Math.max(12, slot * 0.6);
                        points.forEach((point, i) => {
                            const value = values[i];
                            const barHeight = (value / maxValue) * height;
                            const x = i * slot + (slot - barWidth) / 2;
                            const y = height - barHeight;
                            svgMarkup += `<rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="var(--graph-line)" />`;
                        });
                    } else {
                        const step = points.length > 1 ? width / (points.length - 1) : width;
                        const coords = points.map((point, i) => {
                            const value = values[i];
                            const x = step * i;
                            const y = height - (value / maxValue) * height;
                            return { x, y };
                        });
                        const linePath = coords.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
                        const areaPath = `M 0 ${height} ${coords.map(p => `L ${p.x} ${p.y}`).join(' ')} L ${width} ${height} Z`;
                        svgMarkup += `<path d="${areaPath}" fill="var(--graph-fill)" />`;
                        svgMarkup += `<path d="${linePath}" fill="none" stroke="var(--graph-line)" stroke-width="2" />`;
                        coords.forEach((p) => {
                            svgMarkup += `<circle cx="${p.x}" cy="${p.y}" r="3" fill="var(--graph-point)" />`;
                        });
                    }

                    svg.innerHTML = svgMarkup;

                    if (labels) {
                        labels.innerHTML = '';
                        points.forEach((point) => {
                            const span = document.createElement('span');
                            span.textContent = point.label || '';
                            labels.appendChild(span);
                        });
                    }
                });
            }

            function renderDemographics() {
                const activeTile = getActiveTile('demographics');
                const inputContainer = document.getElementById('demo-inputs');
                if (inputContainer) {
                    inputContainer.innerHTML = '';
                    if (activeTile) {
                        activeTile.data.items.forEach((demo, i) => {
                            const div = document.createElement('div');
                            div.className = "section-group grid grid-cols-2 gap-2 items-end";
                            div.innerHTML = `
                                <div class="col-span-2 flex justify-between">
                                     <label class="!mt-0 font-bold text-xs">Region ${i + 1}</label>
                                     <span onclick="removeItem('demo', ${i}, '${activeTile.id}')" class="remove-btn">Remove</span>
                                </div>
                                <input type="text" value="${demo.country}" oninput="updateState('demo', ${i}, 'country', this.value, '${activeTile.id}')" placeholder="Country">
                                <input type="text" value="${demo.val}" oninput="updateState('demo', ${i}, 'val', this.value, '${activeTile.id}')" placeholder="Value">
                            `;
                            inputContainer.appendChild(div);
                        });
                    }
                }

                getTilesByType('demographics').forEach(tile => {
                    const previewGrid = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] .demo-grid`);
                    const titleDisplay = document.querySelector(`.layout-card[data-tile-id="${tile.id}"] [data-edit="demographics.title"]`);
                    if (titleDisplay) titleDisplay.innerText = tile.data.title ?? '';
                    if (!previewGrid) return;
                    previewGrid.innerHTML = '';
                    tile.data.items.forEach((demo, i) => {
                        const div = document.createElement('div');
                        div.className = "p-3";
                        div.innerHTML = `
                            <div class="demo-label editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('demo', ${i}, 'country', this.innerText.trim(), '${tile.id}')"
                                style="font-weight: 700; margin-bottom: 4px;">${demo.country}</div>
                            <div class="demo-value editable" contenteditable="true"
                                onkeydown="if(event.key==='Enter'){event.preventDefault(); this.blur();}"
                                onblur="updateState('demo', ${i}, 'val', this.innerText.trim(), '${tile.id}')"
                                style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace; font-weight: 700; font-size: 1.25rem;">${demo.val}</div>
                        `;
                        previewGrid.appendChild(div);
                    });
                });

                const titleInput = document.getElementById('demographics-title-input');
                if (titleInput && activeTile) {
                    titleInput.value = activeTile.data.title ?? '';
                }
            }

            function updateState(type, index, field, value, tileId) {
                if (type === 'highlight') {
                    const resolved = resolveTileFromArgs('highlights', tileId, index);
                    if (!resolved.tile) return;
                    resolved.tile.data.items[resolved.index] = value;
                    renderHighlights();
                } else if (type === 'kpi') {
                    const resolved = resolveTileFromArgs('kpis', tileId, index);
                    if (!resolved.tile || !resolved.tile.data.kpis[resolved.index]) return;
                    resolved.tile.data.kpis[resolved.index][field] = value;
                    renderKPIs();
                } else if (type === 'blog') {
                    const resolved = resolveTileFromArgs('blogs', tileId, index);
                    if (!resolved.tile || !resolved.tile.data.items[resolved.index]) return;
                    resolved.tile.data.items[resolved.index][field] = value;
                    renderBlogs();
                } else if (type === 'demo') {
                    const resolved = resolveTileFromArgs('demographics', tileId, index);
                    if (!resolved.tile || !resolved.tile.data.items[resolved.index]) return;
                    resolved.tile.data.items[resolved.index][field] = value;
                    renderDemographics();
                } else if (type === 'graphPoint') {
                    const resolved = resolveTileFromArgs('graph', tileId, index);
                    if (!resolved.tile || !resolved.tile.data.series[resolved.index]) return;
                    resolved.tile.data.series[resolved.index][field] = value;
                    renderGraph();
                }
                queueSaveDraft();
            }

            function resolveTileFromArgs(type, tileId, index) {
                if (typeof tileId === 'string') {
                    return { tile: getTileById(tileId), index };
                }
                return { tile: getActiveTile(type), index: tileId };
            }

            function updateKpiValue(tileId, index, value) {
                const resolved = resolveTileFromArgs('kpis', tileId, index);
                if (!resolved.tile || !resolved.tile.data.kpis[resolved.index]) return;
                resolved.tile.data.kpis[resolved.index].curr = value;
                renderKPIs();
                queueSaveDraft();
            }

            function updateKpiDeltaOverride(tileId, index, value) {
                const resolved = resolveTileFromArgs('kpis', tileId, index);
                if (!resolved.tile || !resolved.tile.data.kpis[resolved.index]) return;
                resolved.tile.data.kpis[resolved.index].deltaOverride = value;
                renderKPIs();
                queueSaveDraft();
            }

            function updateKpiTheme(tileId, index, field, value) {
                const resolved = resolveTileFromArgs('kpis', tileId, index);
                if (!resolved.tile || !resolved.tile.data.kpis[resolved.index]) return;
                const kpi = resolved.tile.data.kpis[resolved.index];
                if (!kpi.theme || typeof kpi.theme !== 'object') {
                    kpi.theme = getDefaultKpiTheme(resolved.index);
                }
                kpi.theme[field] = value;
                applyThemeToPreview(state);
                renderKPIs();
                queueSaveDraft();
            }

            function addItem(type, tileId) {
                const resolved = resolveTileFromArgs(type === 'kpi' ? 'kpis' : type === 'demo' ? 'demographics' : type === 'graphPoint' ? 'graph' : type, tileId, 0);
                const tile = resolved.tile;
                if (!tile) return;
                if (type === 'kpi') {
                    const nextIndex = tile.data.kpis.length;
                    tile.data.kpis.push({ title: "New Metric", prev: "", curr: "", deltaOverride: "", theme: getDefaultKpiTheme(nextIndex) });
                    renderKPIs();
                } else if (type === 'highlight') {
                    tile.data.items.push("New highlight point...");
                    renderHighlights();
                } else if (type === 'blog') {
                    tile.data.items.push({ title: "New Blog Post", url: "#", views: "0.0K" });
                    renderBlogs();
                } else if (type === 'demo') {
                    tile.data.items.push({ country: "Region", val: "0.0K" });
                    renderDemographics();
                } else if (type === 'graphPoint') {
                    tile.data.series.push({ label: `P${tile.data.series.length + 1}`, value: "0" });
                    renderGraph();
                }
                queueSaveDraft();
            }

            function removeItem(type, index, tileId) {
                if (!confirm("Are you sure you want to remove this item?")) return;
                const resolved = resolveTileFromArgs(type === 'kpi' ? 'kpis' : type === 'demo' ? 'demographics' : type === 'graphPoint' ? 'graph' : type, tileId, index);
                const tile = resolved.tile;
                if (!tile) return;
                if (type === 'kpi') tile.data.kpis.splice(resolved.index, 1);
                if (type === 'highlight') tile.data.items.splice(resolved.index, 1);
                if (type === 'blog') tile.data.items.splice(resolved.index, 1);
                if (type === 'demo') tile.data.items.splice(resolved.index, 1);
                if (type === 'graphPoint') tile.data.series.splice(resolved.index, 1);
                renderAll();
                queueSaveDraft();
            }

            function updateBigStat(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('bigStat');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('big-stat-input')?.value || '';
                tile.data.value = nextValue;
                renderBigStat();
                queueSaveDraft();
            }

            function updateBigStatLabel(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('bigStat');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('big-stat-label-input')?.value || '';
                tile.data.label = nextValue;
                renderBigStat();
                queueSaveDraft();
            }

            function updateHighlightTitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('highlights');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('highlight-title-input')?.value || '';
                tile.data.title = nextValue;
                renderHighlights();
                queueSaveDraft();
            }

            function updateBlogsTitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('blogs');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('blogs-title-input')?.value || '';
                tile.data.title = nextValue;
                renderBlogs();
                queueSaveDraft();
            }

            function updateBlogsSubtitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('blogs');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('blogs-subtitle-input')?.value || '';
                tile.data.subtitle = nextValue;
                renderBlogs();
                queueSaveDraft();
            }

            function updateDemographicsTitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('demographics');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('demographics-title-input')?.value || '';
                tile.data.title = nextValue;
                renderDemographics();
                queueSaveDraft();
            }

            function updateGraphTitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('graph');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('graph-title-input')?.value || '';
                tile.data.title = nextValue;
                renderGraph();
                queueSaveDraft();
            }

            function updateGraphSubtitle(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('graph');
                if (!tile) return;
                const nextValue = typeof value === 'string' ? value : document.getElementById('graph-subtitle-input')?.value || '';
                tile.data.subtitle = nextValue;
                renderGraph();
                queueSaveDraft();
            }

            function updateGraphType(value, tileId) {
                const tile = typeof tileId === 'string' ? getTileById(tileId) : getActiveTile('graph');
                if (!tile) return;
                tile.data.type = value;
                renderGraph();
                queueSaveDraft();
            }

            function addTile(type) {
                const tile = createTileInstance(type);
                state.tiles.push(tile);
                selectedTileId = tile.id;
                renderAll();
                queueSaveDraft();
            }

            function duplicateTile(tileId) {
                const tile = getTileById(tileId);
                if (!tile) return;
                const clone = createTileInstance(tile.type, {
                    x: tile.x + 20,
                    y: tile.y + 20,
                    width: tile.width,
                    height: tile.height,
                    data: cloneValue(tile.data)
                });
                state.tiles.push(clone);
                selectedTileId = clone.id;
                renderAll();
                queueSaveDraft();
            }

            function removeTile(tileId) {
                const index = state.tiles.findIndex(tile => tile.id === tileId);
                if (index == -1) return;
                state.tiles.splice(index, 1);
                if (selectedTileId === tileId) {
                    selectedTileId = state.tiles[0]?.id || null;
                }
                renderAll();
                queueSaveDraft();
            }

            function normalizeYearlyState() {
                if (state.schemaVersion === undefined || state.schemaVersion === null) {
                    state.schemaVersion = 2;
                }

                normalizeThemeState(state, YEARLY_THEME_DEFAULTS);

                if (!Array.isArray(state.tiles) || state.tiles.length === 0) {
                    state.tiles = buildDefaultTiles();
                }
                normalizeTilesState();

                const kpiTile = getTilesByType('kpis')[0];
                if (kpiTile && Array.isArray(state.kpis) && state.kpis.length) {
                    kpiTile.data.kpis = cloneValue(state.kpis);
                    normalizeKpiList(kpiTile.data.kpis);
                }
                const highlightsTile = getTilesByType('highlights')[0];
                if (highlightsTile && Array.isArray(state.highlights) && state.highlights.length) {
                    highlightsTile.data.items = cloneValue(state.highlights);
                }
                if (highlightsTile && state.highlightTitle) {
                    highlightsTile.data.title = state.highlightTitle;
                }
                const blogsTile = getTilesByType('blogs')[0];
                if (blogsTile && Array.isArray(state.blogs) && state.blogs.length) {
                    blogsTile.data.items = cloneValue(state.blogs);
                }
                if (blogsTile && state.blogTitle) blogsTile.data.title = state.blogTitle;
                if (blogsTile && state.blogSubtitle) blogsTile.data.subtitle = state.blogSubtitle;
                const demoTile = getTilesByType('demographics')[0];
                if (demoTile && Array.isArray(state.demographics) && state.demographics.length) {
                    demoTile.data.items = cloneValue(state.demographics);
                }
                if (demoTile && state.demographicsTitle) demoTile.data.title = state.demographicsTitle;
                const graphTile = getTilesByType('graph')[0];
                if (graphTile && state.graph && typeof state.graph === 'object') {
                    graphTile.data.title = state.graph.title || graphTile.data.title;
                    graphTile.data.subtitle = state.graph.subtitle || graphTile.data.subtitle;
                    graphTile.data.type = state.graph.type || graphTile.data.type;
                    if (Array.isArray(state.graph.series) && state.graph.series.length) {
                        graphTile.data.series = cloneValue(state.graph.series);
                    }
                }
                const bigStatTile = getTilesByType('bigStat')[0];
                if (bigStatTile && state.bigStat && typeof state.bigStat === 'object') {
                    bigStatTile.data.value = state.bigStat.value ?? bigStatTile.data.value;
                    bigStatTile.data.label = state.bigStat.label ?? bigStatTile.data.label;
                }
            }

            function buildJsonTemplate() {
                const width = YEARLY_THEME_DEFAULTS.preview?.width || 1100;
                const gap = YEARLY_THEME_DEFAULTS.layout?.gap ?? 8;
                const leftWidth = Math.round(width * 0.45);
                const rightWidth = Math.max(320, width - leftWidth - gap);
                return {
                    mode: DASHBOARD_TYPE,
                    data: {
                        schemaVersion: 2,
                        theme: cloneValue(YEARLY_THEME_DEFAULTS),
                        tiles: [
                            {
                                id: "tile-1",
                                type: "kpis",
                                x: 0,
                                y: 0,
                                width,
                                height: 120,
                                data: {
                                    kpis: [
                                        {
                                            title: "Active Users",
                                            prev: "33832",
                                            curr: "123883",
                                            deltaOverride: "",
                                            theme: getDefaultKpiTheme(0)
                                        }
                                    ]
                                }
                            },
                            {
                                id: "tile-2",
                                type: "bigStat",
                                x: 0,
                                y: 132,
                                width: leftWidth,
                                height: 200,
                                data: {
                                    value: "181",
                                    label: "Blogs Released in 2025"
                                }
                            },
                            {
                                id: "tile-3",
                                type: "highlights",
                                x: 0,
                                y: 344,
                                width: leftWidth,
                                height: 240,
                                data: {
                                    title: "Yearly Highlights",
                                    items: [
                                        "Yearly highlight one",
                                        "Yearly highlight two"
                                    ]
                                }
                            },
                            {
                                id: "tile-4",
                                type: "blogs",
                                x: leftWidth + gap,
                                y: 132,
                                width: rightWidth,
                                height: 220,
                                data: {
                                    title: "Top Performing Content (2025)",
                                    subtitle: "Sorted by Views",
                                    items: [
                                        { title: "Top Blog Title", views: "13,672" }
                                    ]
                                }
                            },
                            {
                                id: "tile-5",
                                type: "graph",
                                x: leftWidth + gap,
                                y: 364,
                                width: rightWidth,
                                height: 220,
                                data: {
                                    title: "Monthly Growth",
                                    subtitle: "2025",
                                    type: "line",
                                    series: [
                                        { label: "Jan", value: "1200" },
                                        { label: "Feb", value: "1450" },
                                        { label: "Mar", value: "1380" },
                                        { label: "Apr", value: "1620" },
                                        { label: "May", value: "1750" },
                                        { label: "Jun", value: "1920" }
                                    ]
                                }
                            },
                            {
                                id: "tile-6",
                                type: "demographics",
                                x: leftWidth + gap,
                                y: 596,
                                width: rightWidth,
                                height: 140,
                                data: {
                                    title: "Traffic Acquisition",
                                    items: [
                                        { country: "Organic Search", val: "48.0%" }
                                    ]
                                }
                            }
                        ]
                    }
                };
            }

            function applyJson() {
                const input = document.getElementById('json-input');
                if (!input || !input.value.trim()) {
                    alert('Paste JSON first.');
                    return;
                }
                try {
                    const payload = JSON.parse(input.value);
                    if (payload && payload.mode && payload.mode !== DASHBOARD_TYPE) {
                        alert(`This JSON is for \"${payload.mode}\" mode. Switch modes and try again.`);
                        return;
                    }
                    const data = payload && payload.data && typeof payload.data === 'object' ? payload.data : payload;
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid JSON');
                    }
                    state = JSON.parse(JSON.stringify(data));
                    normalizeYearlyState();
                    renderAll();
                    renderInspectorControls();
                    queueSaveDraft();
                } catch (err) {
                    console.error('JSON apply failed:', err);
                    alert('Invalid JSON. Please check the format.');
                }
            }

            async function copyJson() {
                const payload = { mode: DASHBOARD_TYPE, data: getSerializableState() };
                const text = JSON.stringify(payload, null, 2);
                const input = document.getElementById('json-input');
                if (input) input.value = text;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    try {
                        await navigator.clipboard.writeText(text);
                    } catch (err) {
                        console.warn('Clipboard copy failed:', err);
                    }
                } else if (input) {
                    input.select();
                    document.execCommand('copy');
                }
            }

            async function copyJsonTemplate() {
                const payload = buildJsonTemplate();
                const text = JSON.stringify(payload, null, 2);
                const input = document.getElementById('json-input');
                if (input) input.value = text;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    try {
                        await navigator.clipboard.writeText(text);
                    } catch (err) {
                        console.warn('Clipboard copy failed:', err);
                    }
                } else if (input) {
                    input.select();
                    document.execCommand('copy');
                }
            }

            function loadJsonFile(file) {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = () => {
                    const input = document.getElementById('json-input');
                    if (input) input.value = reader.result;
                    applyJson();
                };
                reader.readAsText(file);
            }

            async function saveDraft() {
                if (isExport) return;
                if (!dashboardId) return;
                try {
                    await fetch(`/api/dashboards/${dashboardId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ data: getSerializableState() })
                    });
                } catch (err) {
                    console.error('Auto-save failed:', err);
                }
            }

            function queueSaveDraft() {
                if (isExport) return;
                if (!dashboardId) return;
                if (saveTimer) clearTimeout(saveTimer);
                saveTimer = setTimeout(saveDraft, 600);
            }

            async function saveState() {
                if (!dashboardId) return alert('Server not ready yet.');
                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ data: getSerializableState() })
                    });
                    if (!res.ok) throw new Error(`Save failed (${res.status})`);
                    await renderHistory();
                    alert('State saved successfully!');
                } catch (err) {
                    console.error('Save state failed:', err);
                    alert('Save failed. Check console for details.');
                }
            }

            async function loadState(versionId) {
                if (!confirm("Load this state? Current unsaved changes will be lost.")) return;
                if (!dashboardId) return;
                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions/${versionId}`);
                    if (!res.ok) throw new Error(`Load failed (${res.status})`);
                    const payload = await res.json();
                    if (payload.data && typeof payload.data === 'object') {
                        state = payload.data;
                        renderAll();
                        queueSaveDraft();
                    }
                } catch (err) {
                    console.error('Load state failed:', err);
                    alert('Load failed. Check console for details.');
                }
            }

            async function deleteState(versionId) {
                if (!confirm("Delete this saved state?")) return;
                if (!dashboardId) return;
                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions/${versionId}`, {
                        method: 'DELETE'
                    });
                    if (!res.ok) throw new Error(`Delete failed (${res.status})`);
                    await renderHistory();
                } catch (err) {
                    console.error('Delete state failed:', err);
                    alert('Delete failed. Check console for details.');
                }
            }

            async function clearHistory() {
                if (!confirm("Clear all history?")) return;
                if (!dashboardId) return;
                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions`, {
                        method: 'DELETE'
                    });
                    if (!res.ok) throw new Error(`Clear failed (${res.status})`);
                    await renderHistory();
                } catch (err) {
                    console.error('Clear history failed:', err);
                    alert('Clear failed. Check console for details.');
                }
            }

            async function renderHistory() {
                const list = document.getElementById('history-list');
                if (!list) return;

                if (!dashboardId) {
                    list.innerHTML = '<div class="italic opacity-50 p-2 text-center">Loading...</div>';
                    return;
                }

                try {
                    const res = await fetch(`/api/dashboards/${dashboardId}/versions`);
                    if (!res.ok) throw new Error(`History failed (${res.status})`);
                    const payload = await res.json();
                    const history = payload.versions || [];

                    list.innerHTML = '';
                    if (history.length === 0) {
                        list.innerHTML = '<div class="italic opacity-50 p-2 text-center">No saved states</div>';
                        return;
                    }

                    history.forEach((item, i) => {
                        const div = document.createElement('div');
                        const stamp = item.createdAt ? new Date(item.createdAt).toLocaleString() : '';
                        div.className = "flex justify-between items-center bg-gray-800 p-2 rounded border border-gray-700 hover:border-gray-500 transition-colors group";
                        div.innerHTML = `
                            <div class="cursor-pointer flex-1" onclick="loadState(${item.id})">
                                <div class="font-bold text-gray-300 group-hover:text-cyan-400">Save #${history.length - i}</div>
                                <div class="text-[10px] opacity-70">${stamp}</div>
                            </div>
                            <button onclick="deleteState(${item.id})" class="text-gray-600 hover:text-red-500 ml-2 px-1" title="Delete"></button>
                        `;
                        list.appendChild(div);
                    });
                } catch (err) {
                    console.error('Render history failed:', err);
                    list.innerHTML = '<div class="italic opacity-50 p-2 text-center">Failed to load history</div>';
                }
            }

            function renderAll() {
                renderTileCanvas();
                renderBigStat();
                renderKPIs();
                renderHighlights();
                renderBlogs();
                renderGraph();
                renderDemographics();
                applyThemeToPreview(state);
                updateTileSelectionDisplay();
                registerDragAndDrop();
                registerResizeHandles();
            }

            function prepareExport() {
                normalizeTilesState();
                const preview = document.getElementById('dashboard-preview');
                if (!preview) return null;
                const styles = getComputedStyle(preview);
                const paddingX = (parseFloat(styles.paddingLeft) || 0) + (parseFloat(styles.paddingRight) || 0);
                const paddingY = (parseFloat(styles.paddingTop) || 0) + (parseFloat(styles.paddingBottom) || 0);
                const contentWidth = Math.max(0, preview.clientWidth - paddingX);
                const contentHeight = Math.max(0, preview.clientHeight - paddingY);
                const margin = 16;
                let maxRight = 0;
                let maxBottom = 0;
                state.tiles.forEach(tile => {
                    const right = Number(tile.x || 0) + Number(tile.width || 0);
                    const bottom = Number(tile.y || 0) + Number(tile.height || 0);
                    maxRight = Math.max(maxRight, right);
                    maxBottom = Math.max(maxBottom, bottom);
                });
                const nextWidth = Math.max(contentWidth, maxRight) + paddingX + margin;
                const nextHeight = Math.max(contentHeight, maxBottom) + paddingY + margin;
                preview.style.setProperty('--preview-width', `${Math.ceil(nextWidth)}px`);
                preview.style.height = `${Math.ceil(nextHeight)}px`;
                return { width: Math.ceil(nextWidth), height: Math.ceil(nextHeight) };
            }

            function getSerializableState() {
                normalizeTilesState();
                return {
                    schemaVersion: state.schemaVersion ?? 2,
                    theme: cloneValue(state.theme || YEARLY_THEME_DEFAULTS),
                    tiles: cloneValue(state.tiles || [])
                };
            }

            async function exportFromServer(format) {
                try {
                    if (window.location.protocol === 'file:') {
                        alert('Exports require the app to run on http://localhost:3000. Please start the server and reload.');
                        return;
                    }
                    const payload = {
                        mode: DASHBOARD_TYPE,
                        format,
                        data: getSerializableState()
                    };

                    const res = await fetch('/api/export', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(errorText || `Export failed (${res.status})`);
                    }

                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = format === 'pdf' ? 'yearly-update.pdf' : 'yearly-update.png';
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                } catch (err) {
                    console.error('Export failed:', err);
                    alert('Export failed. Check console for details.');
                }
            }

            function downloadPNG() {
                exportFromServer('png');
            }

            function downloadPDF() {
                exportFromServer('pdf');
            }

            function bindGlobals() {
                cleanupGlobals = exposeHandlers({
                    saveState,
                    clearHistory,
                    addItem,
                    removeItem,
                    updateState,
                    updateKpiValue,
                    updateKpiDeltaOverride,
                    updateKpiTheme,
                    updateBigStat,
                    updateHighlightTitle,
                    updateBlogsTitle,
                    updateBlogsSubtitle,
                    updateDemographicsTitle,
                    updateGraphTitle,
                    updateGraphSubtitle,
                    updateGraphType,
                    applyJson,
                    copyJson,
                    copyJsonTemplate,
                    loadJsonFile,
                    downloadPNG,
                    downloadPDF,
                    loadState,
                    deleteState,
                    setLayoutEditing
                });
            }

            async function init() {
                bindGlobals();
                await loadDashboard();
                renderAll();
                window.__prepareExport__ = prepareExport;
                if (isExport) {
                    document.body.classList.add('export-mode');
                    const inspector = document.querySelector('.studio-inspector');
                    if (inspector) inspector.style.display = 'none';
                    window.__EXPORT_READY__ = true;
                    return;
                }
                renderInspectorControls();
                registerDragAndDrop();
                registerResizeHandles();
                registerCanvasResize();
                registerCanvasPanning();
                registerInlineEditors();
                registerTileSelection();
                setLayoutEditing(false);
                queueSaveDraft();
            }

            init();

            return {
                destroy() {
                    if (saveTimer) clearTimeout(saveTimer);
                    if (cleanupGlobals) cleanupGlobals();
                }
            };
        }
    </script>
</body>

</html>
